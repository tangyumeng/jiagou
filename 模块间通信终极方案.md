# 模块间通信终极方案

## 📌 问题回答

**Q: ProductModule 和 UserModule 两个模块怎样通信？**

**A: 通过 `ModuleManager.shared.module(协议类型.self)` 获取对方模块，然后调用协议方法。**

---

## 🎯 核心答案

### 简单版答案

```swift
// ProductModule 中调用 UserModule 服务

// ✅ 通过协议类型获取模块（无需 import UserModule）
let userModule = ModuleManager.shared.module(UserModuleProtocol.self)

// 调用服务
if let user = userModule?.getCurrentUser() {
    print("当前用户：\(user.name)")
}
```

### 完整版答案

在 CocoaPods 组件化架构中：

```
1. 创建协议层 Pod（ModuleProtocols）
   - 定义 UserModuleProtocol
   - 定义 ProductModuleProtocol
   - 定义数据模型（User, Product）

2. UserModule Pod 和 ProductModule Pod
   - 都只依赖 ModuleProtocols Pod
   - 互不依赖

3. 通信方式：
   - 通过协议类型获取对方模块
   - 调用协议定义的方法
   - 完全解耦
```

---

## 💻 代码实现

### 1. 协议层（ModuleProtocols Pod）

```swift
// ModuleProtocols/Protocols/UserModuleProtocol.swift

import UIKit

public protocol UserModuleProtocol: ModuleProtocol {
    func getCurrentUser() -> User?
    func isLoggedIn() -> Bool
    func login(username: String, password: String, completion: @escaping (Bool, String?) -> Void)
    func logout()
}
```

```swift
// ModuleProtocols/Protocols/ProductModuleProtocol.swift

import UIKit

public protocol ProductModuleProtocol: ModuleProtocol {
    func getProduct(productId: String, completion: @escaping (Product?) -> Void)
    func addToCart(productId: String, quantity: Int) -> Bool
    func syncCart()
    func clearCart()
}
```

---

### 2. ProductModule 调用 UserModule（无需导入）

```swift
// ProductModule/ProductModule.swift

import ModuleProtocols  // ✅ 只依赖协议层

class ProductModule: ProductModuleProtocol {
    static let moduleName = "ProductModule"
    
    required init() {}
    
    func addToCart(productId: String, quantity: Int) -> Bool {
        // ✅ 通过协议类型获取 UserModule（不需要 import UserModule）
        guard let userModule = ModuleManager.shared.module(UserModuleProtocol.self) else {
            print("❌ 无法获取 UserModule")
            return false
        }
        
        // 检查登录状态
        guard let user = userModule.getCurrentUser() else {
            print("❌ 用户未登录")
            return false
        }
        
        // 添加到购物车
        print("✅ 用户 \(user.name) 添加商品")
        return true
    }
    
    func syncCart() {
        // ✅ 同样通过协议类型
        guard let userModule = ModuleManager.shared.module(UserModuleProtocol.self) else {
            return
        }
        
        if let user = userModule.getCurrentUser() {
            print("🔄 为用户 \(user.name) 同步购物车")
            // 网络请求同步购物车...
        }
    }
}
```

**依赖关系：**
```
ProductModule.podspec:
  s.dependency 'ModuleProtocols'  ✅ 只依赖协议层
  # s.dependency 'UserModule'  ❌ 不依赖 UserModule
```

---

### 3. UserModule 调用 ProductModule（无需导入）

```swift
// UserModule/UserModule.swift

import ModuleProtocols  // ✅ 只依赖协议层

class UserModule: UserModuleProtocol {
    static let moduleName = "UserModule"
    
    private var currentUser: User?
    
    required init() {}
    
    func login(username: String, password: String, completion: @escaping (Bool, String?) -> Void) {
        // 登录逻辑...
        currentUser = User(id: "123", name: username)
        
        // 登录成功后，通知其他模块
        notifyOtherModulesAfterLogin()
        
        completion(true, nil)
    }
    
    func logout() {
        currentUser = nil
        
        // 登出后，通知其他模块
        notifyOtherModulesAfterLogout()
    }
    
    private func notifyOtherModulesAfterLogin() {
        // ✅ 通过协议类型获取 ProductModule（不需要 import ProductModule）
        if let productModule = ModuleManager.shared.module(ProductModuleProtocol.self) {
            print("🔄 UserModule: 通知 ProductModule 同步购物车")
            productModule.syncCart()
        }
    }
    
    private func notifyOtherModulesAfterLogout() {
        // ✅ 通过协议类型获取 ProductModule
        if let productModule = ModuleManager.shared.module(ProductModuleProtocol.self) {
            print("🗑️ UserModule: 通知 ProductModule 清空购物车")
            productModule.clearCart()
        }
    }
}
```

**依赖关系：**
```
UserModule.podspec:
  s.dependency 'ModuleProtocols'  ✅ 只依赖协议层
  # s.dependency 'ProductModule'  ❌ 不依赖 ProductModule
```

---

## 🔍 为什么不需要 import？

### 传统方式（❌ 需要导入）

```swift
// ProductModule.swift

import UserModule  // ❌ 需要导入具体模块

func addToCart() {
    let userModule = UserModule.shared  // 使用具体类
    let user = userModule.getCurrentUser()
}
```

### 协议层方式（✅ 无需导入）

```swift
// ProductModule.swift

import ModuleProtocols  // ✅ 只导入协议层（已经包含 UserModuleProtocol）

func addToCart() {
    // 使用协议类型（在 ModuleProtocols 中定义）
    let userModule = ModuleManager.shared.module(UserModuleProtocol.self)
    let user = userModule?.getCurrentUser()
}
```

**关键：**
- `UserModuleProtocol` 定义在 `ModuleProtocols` 中
- `ProductModule` 导入了 `ModuleProtocols`，所以可以使用 `UserModuleProtocol`
- 不需要导入 `UserModule`（具体实现）

---

## 📊 通信流程图

### 场景：商品购买流程（跨模块）

```
┌────────────────────────────────────┐
│   ProductDetailViewController      │
│   (商品详情页)                      │
└────────────────────────────────────┘
              ↓ 用户点击购买
┌────────────────────────────────────┐
│   ProductModule.addToCart()        │
└────────────────────────────────────┘
              ↓
┌────────────────────────────────────┐
│   ModuleManager.shared.module(     │
│     UserModuleProtocol.self        │ ← 通过协议类型获取
│   )                                 │
└────────────────────────────────────┘
              ↓
┌────────────────────────────────────┐
│   ModuleManager 查找:               │
│   哪个模块实现了 UserModuleProtocol?│
│   → 找到 UserModule                │
└────────────────────────────────────┘
              ↓
┌────────────────────────────────────┐
│   UserModule 实例                  │
│   (作为 UserModuleProtocol 类型)   │
└────────────────────────────────────┘
              ↓
┌────────────────────────────────────┐
│   调用协议方法：                    │
│   userModule.getCurrentUser()      │
└────────────────────────────────────┘
              ↓
┌────────────────────────────────────┐
│   返回 User 对象                   │
└────────────────────────────────────┘
```

---

## 🔄 双向通信示例

### ProductModule ⇄ UserModule

```swift
// 方向1：ProductModule → UserModule
class ProductModule {
    func addToCart(productId: String, quantity: Int) -> Bool {
        // 获取 UserModule（通过协议）
        let userModule = ModuleManager.shared.module(UserModuleProtocol.self)
        
        // 调用 UserModule 服务
        if let user = userModule?.getCurrentUser() {
            print("用户 \(user.name) 添加商品")
            return true
        }
        return false
    }
}

// 方向2：UserModule → ProductModule
class UserModule {
    func login(...) {
        // 登录成功
        
        // 获取 ProductModule（通过协议）
        let productModule = ModuleManager.shared.module(ProductModuleProtocol.self)
        
        // 调用 ProductModule 服务
        productModule?.syncCart()
    }
}
```

**关键：**
- 双方都通过协议类型调用
- 双方都无需 import 对方
- 完全解耦

---

## ✅ 项目依赖关系

### Podfile

```ruby
target 'MyApp' do
  # 协议层
  pod 'ModuleProtocols'
  
  # 业务模块
  pod 'UserModule'
  pod 'ProductModule'
end
```

### 各 Pod 的依赖

```
ModuleProtocols.podspec:
  # 不依赖任何业务模块

UserModule.podspec:
  s.dependency 'ModuleProtocols'  # ✅ 只依赖协议层

ProductModule.podspec:
  s.dependency 'ModuleProtocols'  # ✅ 只依赖协议层
```

### Import 语句

```swift
// UserModule/UserModule.swift
import ModuleProtocols  // ✅ 可以使用 ProductModuleProtocol

// ProductModule/ProductModule.swift
import ModuleProtocols  // ✅ 可以使用 UserModuleProtocol

// 注意：不需要 import 对方！
```

---

## 🎯 实战测试

### 测试登录后同步购物车

```
1. 运行 App（⌘ + R）
2. 主页 → 协议路由（模块化）
3. 点击 [调用登录服务]
4. 观察控制台日志：

控制台输出：
[10:30:00] 📤 调用登录服务（UserModule）
[10:30:00] 🔐 登录：zhangsan
[10:30:01] 🔄 UserModule: 通知其他模块同步数据
[10:30:01] 🔄 UserModule: 通知 ProductModule 同步购物车
[10:30:01] 🔄 同步购物车...
[10:30:01] ✅ 为用户 zhangsan 同步购物车
[10:30:01] ✅ 登录成功
```

### 测试添加购物车（检查登录）

```
1. 点击 [打开商品详情页]
2. 进入商品详情页
3. 点击 [加入购物车]

如果已登录：
✅ 已添加到购物车

如果未登录：
❌ 用户未登录，无法添加到购物车
```

---

## 📚 关键代码汇总

### ModuleManager 核心方法

```swift
// 支持通过协议类型获取模块
func module<T: ModuleProtocol>(_ type: T.Type) -> T? {
    // 遍历所有注册的模块
    for (_, moduleType) in modules {
        // 检查是否实现了该协议
        if let matchedType = moduleType as? T.Type {
            return matchedType.init()
        }
    }
    return nil
}
```

### ProductModule 调用 UserModule

```swift
// ✅ 无需 import UserModule
let userModule = ModuleManager.shared.module(UserModuleProtocol.self)
let user = userModule?.getCurrentUser()
```

### UserModule 调用 ProductModule

```swift
// ✅ 无需 import ProductModule
let productModule = ModuleManager.shared.module(ProductModuleProtocol.self)
productModule?.syncCart()
```

---

## ✅ 总结

### 核心机制

**通过协议层（ModuleProtocols）作为中间层，实现模块间完全解耦通信**

### 依赖关系

```
         ModuleProtocols Pod
               ↙        ↘
    UserModule Pod    ProductModule Pod
         ↓                  ↓
  可使用对方协议      可使用对方协议
  UserModuleProtocol ← → ProductModuleProtocol
         ↓                  ↓
  但不依赖对方实现    但不依赖对方实现
  UserModule ✗ ✗ ✗ → ProductModule
```

### 关键优势

✅ **零依赖** - 两个 Pod 互不依赖  
✅ **完全解耦** - 通过协议通信  
✅ **独立开发** - 团队并行工作  
✅ **独立测试** - 可 Mock 对方  
✅ **类型安全** - 编译时检查  

### 通信方式

```swift
// ProductModule 获取 UserModule
let userModule = ModuleManager.shared.module(UserModuleProtocol.self)

// UserModule 获取 ProductModule
let productModule = ModuleManager.shared.module(ProductModuleProtocol.self)
```

---

## 🎉 实现完成

### 已在代码中实现

1. ✅ **ProductModule.addToCart()** - 调用 UserModule 检查登录
2. ✅ **ProductModule.syncCart()** - 调用 UserModule 获取用户信息
3. ✅ **UserModule.login()** - 登录后调用 ProductModule 同步购物车
4. ✅ **UserModule.logout()** - 登出后调用 ProductModule 清空购物车

### 查看代码

- `ProductModule.swift` 第 118-173 行
- `UserModule.swift` 第 126-159 行

---

**模块间通信已完全实现！通过协议层实现完全解耦！🚀**

**立即运行测试：主页 → 协议路由（模块化） → 测试跨模块通信！📱**

