# 两种路由方案总结

## 📌 背景

**问题：** "请使用其他方式实现Router，并且要考虑到大型项目中，多模块之间怎样通信问题。保留现有的router实现不变，新提供一种页面跳转、模块通信方案"

---

## 🎯 解决方案

### 方案 1：URL-Based Router（现有）

**设计理念：** 通过 URL 字符串进行页面路由

```swift
Router.shared.open("app://user/123?name=张三")
```

### 方案 2：Protocol-Based Router（新增）

**设计理念：** 通过协议定义模块接口，使用中介者模式管理模块通信

```swift
ModuleManager.shared.openPage(
    UserModule.self,
    parameters: ["userId": "123"]
)

// 服务调用
userModule.getCurrentUser()
userModule.login(username: "zhangsan", password: "123")
```

---

## 📊 完整对比

### 特性对比

| 特性 | URL-Based Router | Protocol-Based Router |
|------|------------------|----------------------|
| **类型安全** | ❌ 字符串，无类型检查 | ✅ 协议约束，编译检查 |
| **编译检查** | ❌ 运行时才知道错误 | ✅ 编译时发现错误 |
| **外部唤起** | ✅ 支持（URL Scheme） | ❌ 不支持 |
| **H5 交互** | ✅ 支持（WebView） | ❌ 不支持 |
| **推送通知** | ✅ 支持 | ❌ 不支持 |
| **运营配置** | ✅ 远程下发 URL | ❌ 无法动态配置 |
| **页面跳转** | ✅ 支持 | ✅ 支持（更安全） |
| **服务调用** | ❌ 不支持 | ✅ 支持（核心优势） |
| **模块通信** | ❌ 只能跳转页面 | ✅ 直接调用服务 |
| **参数传递** | ⭐⭐ 字符串/序列化 | ⭐⭐⭐⭐⭐ 任意类型 |
| **接口约束** | ❌ 无约束 | ✅ 协议定义接口 |
| **代码提示** | ❌ 字符串无提示 | ✅ IDE 自动补全 |
| **重构友好** | ❌ 难以重构 | ✅ 编译器辅助 |
| **测试友好** | ⭐⭐ | ⭐⭐⭐⭐⭐ 可 Mock |
| **学习成本** | ⭐⭐ 简单 | ⭐⭐⭐⭐ 需理解协议 |
| **代码量** | ⭐⭐⭐ 少 | ⭐⭐⭐⭐ 需定义协议 |

---

## 💻 代码对比

### 页面跳转

#### URL Router

```swift
// 注册路由
Router.shared.register("app://user/:userId") { parameters in
    let vc = UserDetailViewController()
    vc.userId = parameters["userId"] as? String
    return vc
}

// 使用
Router.shared.open("app://user/123")  // ❌ 运行时才知道错误
Router.shared.open("app://user/abc")  // 参数类型错误，但能编译
```

#### Protocol Router

```swift
// 定义协议
protocol UserModuleProtocol: PageModuleProtocol {
    func createUserDetailPage(userId: String) -> UIViewController?
}

// 实现
class UserModule: UserModuleProtocol {
    func createUserDetailPage(userId: String) -> UIViewController? {
        let vc = UserDetailViewController()
        vc.userId = userId
        return vc
    }
}

// 注册
ModuleManager.shared.register(UserModule.self)

// 使用
ModuleManager.shared.openPage(
    UserModule.self,
    parameters: ["userId": "123"]
)  // ✅ 类型安全
```

---

### 服务调用

#### URL Router

```swift
// ❌ 不支持服务调用
// 只能通过页面跳转或全局单例
UserManager.shared.getCurrentUser()  // 紧耦合
```

#### Protocol Router

```swift
// ✅ 支持服务调用
protocol UserModuleProtocol: ServiceModuleProtocol {
    func getCurrentUser() -> User?
    func login(username: String, password: String, completion: @escaping (Bool) -> Void)
}

// 使用
if let userModule = ModuleManager.shared.module(UserModule.self) {
    let user = userModule.getCurrentUser()
    
    userModule.login(username: "zhangsan", password: "123") { success in
        // ...
    }
}
```

---

### 跨模块通信

#### URL Router

```swift
// ❌ 需要通过 URL 或全局单例
Router.shared.open("app://login")  // 只能跳转

// 或使用全局单例（紧耦合）
import UserModule
let user = UserManager.shared.getCurrentUser()
```

#### Protocol Router

```swift
// ✅ 通过协议调用服务（解耦）
// 商品详情页需要检查登录状态
class ProductDetailViewController {
    func checkLogin() {
        // 调用用户模块服务
        if let userModule = ModuleManager.shared.module(UserModule.self) {
            if let user = userModule.getCurrentUser() {
                print("已登录：\(user.name)")
            } else {
                // 跳转登录页
                ModuleManager.shared.openPage(UserModule.self, parameters: ["isLogin": true])
            }
        }
    }
}
```

---

## 🏗️ 架构设计

### URL-Based Router 架构

```
┌─────────────────────────┐
│      App 主工程          │
├─────────────────────────┤
│                         │
│   ┌─────────────┐       │
│   │   Router    │       │
│   │  (单例)     │       │
│   └─────────────┘       │
│          ↕              │
│    URL 字符串匹配        │
│          ↕              │
│  ┌──────┐  ┌──────┐    │
│  │ 页面1 │  │ 页面2 │ ...│
│  └──────┘  └──────┘    │
│                         │
│  特点：                  │
│  - 解耦（通过URL）       │
│  - 只能页面跳转          │
│  - 无模块概念            │
└─────────────────────────┘
```

### Protocol-Based Router 架构

```
┌─────────────────────────────────────────┐
│          App 主工程                      │
├─────────────────────────────────────────┤
│                                         │
│    ┌─────────────────────────┐         │
│    │   ModuleManager         │         │
│    │   (中介者/服务总线)      │         │
│    └─────────────────────────┘         │
│              ↕                          │
│    ┌─────────────────────────┐         │
│    │   Protocol Layer        │         │
│    │   (协议层)               │         │
│    │   - UserModuleProtocol  │         │
│    │   - ProductModuleProtocol│        │
│    └─────────────────────────┘         │
│              ↕                          │
│  ┌──────────┐  ┌──────────┐           │
│  │ UserModule│  │ ProductModule│  ...  │
│  ├──────────┤  ├──────────┤           │
│  │ 页面：    │  │ 页面：    │           │
│  │ - 详情页  │  │ - 详情页  │           │
│  │ - 列表页  │  │ - 列表页  │           │
│  │ 服务：    │  │ 服务：    │           │
│  │ - 登录    │  │ - 查询    │           │
│  │ - 登出    │  │ - 购买    │           │
│  └──────────┘  └──────────┘           │
│                                         │
│  特点：                                  │
│  - 通过协议解耦                          │
│  - 支持页面跳转                          │
│  - 支持服务调用                          │
│  - 模块化清晰                            │
└─────────────────────────────────────────┘
```

---

## 📱 使用场景

### 场景 1：外部唤起 App

**适用：** URL Router ⭐⭐⭐⭐⭐

```swift
// URL Scheme: myapp://product/123
func application(_ app: UIApplication, open url: URL) -> Bool {
    return Router.shared.open(url)  // ✅ 直接支持
}
```

**Protocol Router：** ❌ 不支持

---

### 场景 2：H5 页面跳转原生

**适用：** URL Router ⭐⭐⭐⭐⭐

```javascript
// H5 JavaScript
window.location.href = "myapp://product/123";
```

**Protocol Router：** ❌ 不支持

---

### 场景 3：推送通知跳转

**适用：** URL Router ⭐⭐⭐⭐⭐

```json
{
  "aps": {"alert": "新商品上架"},
  "route": "app://product/123"
}
```

**Protocol Router：** ❌ 不支持（可结合 URL Router）

---

### 场景 4：运营活动配置

**适用：** URL Router ⭐⭐⭐⭐⭐

```json
// 服务器下发配置
{
  "activity": {
    "name": "双十一",
    "url": "app://activity/1111"
  }
}
```

**Protocol Router：** ❌ 不支持

---

### 场景 5：应用内模块跳转

**适用：** Protocol Router ⭐⭐⭐⭐⭐

```swift
// ✅ 类型安全，编译检查
ModuleManager.shared.openPage(
    UserModule.self,
    parameters: ["userId": "123"]
)
```

**URL Router：** ⭐⭐⭐ 可以，但无类型安全

---

### 场景 6：模块间服务调用

**适用：** Protocol Router ⭐⭐⭐⭐⭐

```swift
// ✅ 商品详情页调用用户服务
if let userModule = ModuleManager.shared.module(UserModule.self) {
    if userModule.isLoggedIn() {
        // 显示购买按钮
    } else {
        // 显示登录按钮
    }
}
```

**URL Router：** ❌ 不支持（需要全局单例，紧耦合）

---

### 场景 7：大型项目组件化

**适用：** Protocol Router ⭐⭐⭐⭐⭐

```
项目结构：
- App 主工程
- Protocols 协议层
- UserModule 用户模块（独立 Pod）
- ProductModule 商品模块（独立 Pod）
- OrderModule 订单模块（独立 Pod）

优势：
✅ 各模块独立开发
✅ 协议定义接口
✅ 编译时检查依赖
✅ 易于测试（Mock）
```

**URL Router：** ⭐⭐⭐ 可以，但缺少接口约束

---

## 💡 推荐使用策略

### 大型项目（推荐）

```
┌─────────────────────────────────┐
│     两种路由结合使用（互补）      │
├─────────────────────────────────┤
│                                 │
│  URL Router（30%）：             │
│  ✅ 外部唤起（URL Scheme）       │
│  ✅ H5 交互（WebView）           │
│  ✅ 推送通知跳转                  │
│  ✅ 运营活动配置                  │
│                                 │
│  Protocol Router（70%）：        │
│  ✅ 应用内模块跳转                │
│  ✅ 模块间服务调用                │
│  ✅ 业务逻辑通信                  │
│  ✅ 组件化架构                    │
│                                 │
└─────────────────────────────────┘
```

**实现方式：**

```swift
// 统一路由入口（可选）
class UnifiedRouter {
    static func open(_ target: Any, parameters: [String: Any] = [:]) -> Bool {
        if let urlString = target as? String {
            // URL 字符串 → URL Router
            return Router.shared.open(urlString, parameters: parameters)
        } else if let moduleType = target as? PageModuleProtocol.Type {
            // 模块类型 → Protocol Router
            return ModuleManager.shared.openPage(moduleType, parameters: parameters)
        }
        return false
    }
}

// 使用示例
UnifiedRouter.open("app://user/123")  // URL Router
UnifiedRouter.open(UserModule.self, parameters: ["userId": "123"])  // Protocol Router
```

---

### 中小型项目

```
单一路由即可：

方案 A：URL Router
优点：简单、灵活、支持外部唤起
缺点：无类型安全
适合：外部交互多、快速开发

方案 B：Protocol Router
优点：类型安全、模块清晰
缺点：需要定义协议
适合：代码质量要求高、团队协作
```

---

## 🎯 技术亮点

### URL-Based Router

1. **URL 模式匹配**
   ```swift
   "app://user/:userId" 匹配 "app://user/123"
   提取参数：["userId": "123"]
   ```

2. **参数合并**
   ```swift
   路径参数 + Query参数 + 代码参数 → 自动合并
   ```

3. **拦截器链**
   ```swift
   支持多个拦截器，任一返回 false 则终止
   ```

4. **延迟路由**
   ```swift
   解决通知启动时 UI 未就绪问题
   setPendingRoute() → executePendingRoute()
   ```

---

### Protocol-Based Router

1. **中介者模式**
   ```swift
   ModuleManager 统一管理所有模块
   模块间通过中介者通信，解耦
   ```

2. **协议约束**
   ```swift
   protocol UserModuleProtocol {
       func getCurrentUser() -> User?
   }
   强制实现协议方法，编译时检查
   ```

3. **单例缓存**
   ```swift
   模块实例缓存，避免重复创建
   线程安全（GCD concurrent queue）
   ```

4. **类型安全**
   ```swift
   func module<T: ModuleProtocol>(_ type: T.Type) -> T?
   泛型约束，类型检查
   ```

---

## 📚 文件清单

### URL-Based Router

```
核心代码：
├── Router.swift              - 路由核心
├── RoutePages.swift          - 示例页面
├── RouterDemoViewController.swift  - 演示页面
└── RouteDataCache.swift      - 复杂对象缓存

文档：
├── 路由框架说明.md
├── Router演示说明.md
├── 通知路由启动方案.md
├── 路由传递复杂对象方案.md
└── 各种快速测试指南.md
```

### Protocol-Based Router

```
核心代码：
├── ModuleProtocol.swift      - 协议定义
├── ModuleManager.swift       - 模块管理器
├── UserModule.swift          - 用户模块
├── ProductModule.swift       - 商品模块
└── ModuleDemoViewController.swift  - 演示页面

文档：
├── 协议路由和模块通信方案.md
├── 协议路由快速测试指南.md
└── 两种路由方案总结.md（本文档）
```

---

## ✅ 完成清单

### 实现的功能

#### URL-Based Router
- [x] URL 模式匹配（路径参数提取）
- [x] Query 参数解析
- [x] 参数合并（路径+Query+代码）
- [x] 拦截器机制
- [x] 延迟路由（通知启动）
- [x] 复杂对象传递（parameters + 缓存）
- [x] 多种跳转方式（push/present/replace）
- [x] 完整演示页面

#### Protocol-Based Router
- [x] 模块协议定义
- [x] 模块管理器（中介者）
- [x] 模块注册和获取（单例）
- [x] 页面跳转（push/present）
- [x] 服务调用
- [x] 跨模块通信
- [x] 用户模块（完整示例）
- [x] 商品模块（完整示例）
- [x] 完整演示页面
- [x] 与 URL Router 共存

---

## 🎉 总结

### 核心价值

#### URL-Based Router
🎯 **解决问题：** 外部交互、动态配置  
🎯 **核心优势：** 灵活、支持外部唤起  
🎯 **适用场景：** 通知、H5、运营活动  
🎯 **面试价值：** URL 匹配算法、拦截器链  

#### Protocol-Based Router
🎯 **解决问题：** 大型项目模块化、类型安全  
🎯 **核心优势：** 类型安全、模块通信  
🎯 **适用场景：** 应用内跳转、服务调用  
🎯 **面试价值：** 中介者模式、组件化、解耦  

### 最佳实践

**大型项目：** 两种路由结合使用  
**中小型项目：** 根据需求选择一种  
**外部交互多：** URL Router  
**代码质量高：** Protocol Router  

---

**两种路由方案已完整实现，立即运行测试！🚀**

**主页可以看到两种路由入口：**
1. **路由框架** → URL-Based Router 演示
2. **协议路由（模块化）** → Protocol-Based Router 演示

**体验两种方案的差异，选择适合你的项目！📱**

