# 协议路由和模块通信方案

## 📌 方案对比

### 现有方案：URL-Based Router

```swift
// 优点：
✅ 支持外部唤起（URL Scheme、Universal Links）
✅ 灵活（通过 URL 字符串）
✅ 支持远程配置
✅ 适合 H5 交互

// 缺点：
❌ 无类型安全（字符串 URL）
❌ 无编译检查（运行时才知道错误）
❌ 只能页面跳转（不支持服务调用）
❌ 参数传递麻烦（需要序列化）
```

### 新方案：Protocol-Based + Mediator

```swift
// 优点：
✅ 类型安全（协议定义接口）
✅ 编译时检查（参数类型错误立即发现）
✅ 支持页面跳转
✅ 支持服务调用（模块间通信）
✅ 支持依赖注入
✅ 适合组件化架构

// 缺点：
❌ 不支持外部唤起
❌ 需要定义协议（代码量稍多）
❌ 无法远程配置
```

---

## 🎯 设计思路

### 架构图

```
┌─────────────────────────────────────────┐
│          App 主工程                      │
├─────────────────────────────────────────┤
│                                         │
│    ┌─────────────────────────┐         │
│    │   ModuleManager         │         │
│    │   (中介者/服务总线)      │         │
│    └─────────────────────────┘         │
│              ↕                          │
│    ┌─────────────────────────┐         │
│    │   Protocol Layer        │         │
│    │   (协议层)               │         │
│    └─────────────────────────┘         │
│              ↕                          │
│  ┌──────┐  ┌──────┐  ┌──────┐         │
│  │ 用户  │  │ 商品  │  │ 订单  │  ...    │
│  │ 模块  │  │ 模块  │  │ 模块  │         │
│  └──────┘  └──────┘  └──────┘         │
└─────────────────────────────────────────┘

每个模块：
- 定义协议（Protocol）
- 实现协议（Implementation）
- 注册到 ModuleManager
```

---

## 💻 核心实现

### 1. 模块协议定义

```swift
/// 模块协议基类
protocol ModuleProtocol {
    /// 模块名称
    static var moduleName: String { get }
    
    /// 模块初始化
    init()
}

/// 页面模块协议（可以创建 ViewController）
protocol PageModuleProtocol: ModuleProtocol {
    /// 创建页面
    func createViewController(with parameters: [String: Any]) -> UIViewController?
}

/// 服务模块协议（提供服务，不创建页面）
protocol ServiceModuleProtocol: ModuleProtocol {
    /// 服务方法（子类自定义）
}
```

---

### 2. 模块管理器（Mediator 中介者）

```swift
/// 模块管理器（单例）
class ModuleManager {
    static let shared = ModuleManager()
    
    // 注册的模块
    private var modules: [String: ModuleProtocol.Type] = [:]
    
    // 模块实例缓存（单例模式）
    private var instances: [String: ModuleProtocol] = [:]
    
    private init() {}
    
    // MARK: - 注册模块
    
    /// 注册模块
    func register<T: ModuleProtocol>(_ moduleType: T.Type) {
        let moduleName = moduleType.moduleName
        modules[moduleName] = moduleType
        print("✅ 注册模块：\(moduleName)")
    }
    
    // MARK: - 获取模块
    
    /// 获取模块实例（单例）
    func module<T: ModuleProtocol>(_ type: T.Type) -> T? {
        let moduleName = type.moduleName
        
        // 从缓存获取
        if let instance = instances[moduleName] as? T {
            return instance
        }
        
        // 创建新实例
        guard let moduleType = modules[moduleName] as? T.Type else {
            print("❌ 模块未注册：\(moduleName)")
            return nil
        }
        
        let instance = moduleType.init()
        instances[moduleName] = instance
        return instance
    }
    
    // MARK: - 页面跳转
    
    /// 打开页面
    @discardableResult
    func openPage<T: PageModuleProtocol>(
        _ moduleType: T.Type,
        parameters: [String: Any] = [:],
        from source: UIViewController?,
        animated: Bool = true
    ) -> Bool {
        guard let module = self.module(moduleType) else {
            return false
        }
        
        guard let destination = module.createViewController(with: parameters) else {
            print("❌ 创建页面失败")
            return false
        }
        
        // 执行跳转
        guard let source = source ?? Router.shared.currentViewController() else {
            print("❌ 没有源 ViewController")
            return false
        }
        
        source.navigationController?.pushViewController(destination, animated: animated)
        return true
    }
}
```

---

### 3. 具体模块示例

#### 用户模块协议

```swift
/// 用户模块协议
protocol UserModuleProtocol: PageModuleProtocol, ServiceModuleProtocol {
    /// 创建用户详情页
    func createUserDetailPage(userId: String) -> UIViewController?
    
    /// 创建用户列表页
    func createUserListPage() -> UIViewController?
    
    /// 获取当前用户信息（服务）
    func getCurrentUser() -> User?
    
    /// 登录（服务）
    func login(username: String, password: String, completion: @escaping (Bool) -> Void)
    
    /// 登出（服务）
    func logout()
}

/// 用户模块实现
class UserModule: UserModuleProtocol {
    static let moduleName = "UserModule"
    
    required init() {}
    
    // MARK: - PageModuleProtocol
    
    func createViewController(with parameters: [String : Any]) -> UIViewController? {
        // 根据参数决定创建哪个页面
        if let userId = parameters["userId"] as? String {
            return createUserDetailPage(userId: userId)
        } else {
            return createUserListPage()
        }
    }
    
    // MARK: - 页面创建
    
    func createUserDetailPage(userId: String) -> UIViewController? {
        let vc = UserDetailViewController()
        vc.userId = userId
        return vc
    }
    
    func createUserListPage() -> UIViewController? {
        return UserListViewController()
    }
    
    // MARK: - 服务方法
    
    func getCurrentUser() -> User? {
        // 从本地或网络获取用户信息
        return User(id: "123", name: "张三", avatar: "avatar.jpg")
    }
    
    func login(username: String, password: String, completion: @escaping (Bool) -> Void) {
        // 执行登录逻辑
        print("🔐 登录：\(username)")
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            completion(true)
        }
    }
    
    func logout() {
        print("🔓 登出")
        // 清除用户信息
    }
}
```

#### 商品模块协议

```swift
/// 商品模块协议
protocol ProductModuleProtocol: PageModuleProtocol, ServiceModuleProtocol {
    /// 创建商品详情页
    func createProductDetailPage(productId: String) -> UIViewController?
    
    /// 创建商品列表页
    func createProductListPage(category: String?) -> UIViewController?
    
    /// 获取商品信息（服务）
    func getProduct(productId: String, completion: @escaping (Product?) -> Void)
    
    /// 添加到购物车（服务）
    func addToCart(productId: String, quantity: Int) -> Bool
}

/// 商品模块实现
class ProductModule: ProductModuleProtocol {
    static let moduleName = "ProductModule"
    
    required init() {}
    
    // MARK: - PageModuleProtocol
    
    func createViewController(with parameters: [String : Any]) -> UIViewController? {
        if let productId = parameters["productId"] as? String {
            return createProductDetailPage(productId: productId)
        } else {
            let category = parameters["category"] as? String
            return createProductListPage(category: category)
        }
    }
    
    // MARK: - 页面创建
    
    func createProductDetailPage(productId: String) -> UIViewController? {
        let vc = ProductDetailViewController()
        vc.productId = productId
        return vc
    }
    
    func createProductListPage(category: String?) -> UIViewController? {
        let vc = ProductListViewController()
        vc.category = category
        return vc
    }
    
    // MARK: - 服务方法
    
    func getProduct(productId: String, completion: @escaping (Product?) -> Void) {
        // 从网络获取商品信息
        print("📦 获取商品：\(productId)")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            let product = Product(id: productId, name: "iPhone 15", price: 5999)
            completion(product)
        }
    }
    
    func addToCart(productId: String, quantity: Int) -> Bool {
        print("🛒 添加到购物车：\(productId) x\(quantity)")
        return true
    }
}
```

---

## 📱 使用方式

### 1. 注册模块（AppDelegate）

```swift
func application(...) -> Bool {
    // 注册所有模块
    registerModules()
    return true
}

func registerModules() {
    let manager = ModuleManager.shared
    
    // 注册用户模块
    manager.register(UserModule.self)
    
    // 注册商品模块
    manager.register(ProductModule.self)
    
    // 注册订单模块
    manager.register(OrderModule.self)
    
    print("✅ 所有模块已注册")
}
```

---

### 2. 页面跳转

#### 方式1：通过 ModuleManager（推荐）

```swift
// 打开用户详情页
ModuleManager.shared.openPage(
    UserModule.self,
    parameters: ["userId": "12345"],
    from: self
)

// 打开商品列表页
ModuleManager.shared.openPage(
    ProductModule.self,
    parameters: ["category": "电子产品"],
    from: self
)
```

#### 方式2：通过模块协议（类型安全）

```swift
// 获取用户模块
if let userModule = ModuleManager.shared.module(UserModule.self) {
    // 创建用户详情页
    if let vc = userModule.createUserDetailPage(userId: "12345") {
        navigationController?.pushViewController(vc, animated: true)
    }
}
```

---

### 3. 服务调用（模块间通信）

#### 获取用户信息

```swift
// 在任何地方调用用户服务
if let userModule = ModuleManager.shared.module(UserModule.self) {
    if let user = userModule.getCurrentUser() {
        print("当前用户：\(user.name)")
    }
}
```

#### 调用登录服务

```swift
if let userModule = ModuleManager.shared.module(UserModule.self) {
    userModule.login(username: "zhangsan", password: "123456") { success in
        if success {
            print("✅ 登录成功")
        }
    }
}
```

#### 获取商品信息

```swift
if let productModule = ModuleManager.shared.module(ProductModule.self) {
    productModule.getProduct(productId: "8888") { product in
        if let product = product {
            print("商品：\(product.name)，价格：\(product.price)")
        }
    }
}
```

#### 添加到购物车

```swift
if let productModule = ModuleManager.shared.module(ProductModule.self) {
    let success = productModule.addToCart(productId: "8888", quantity: 2)
    print(success ? "✅ 已添加" : "❌ 添加失败")
}
```

---

### 4. 跨模块通信示例

#### 场景：商品详情页调用用户服务

```swift
class ProductDetailViewController: UIViewController {
    var productId: String?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 1. 获取商品信息（本模块服务）
        if let productModule = ModuleManager.shared.module(ProductModule.self) {
            productModule.getProduct(productId: productId ?? "") { [weak self] product in
                self?.displayProduct(product)
            }
        }
        
        // 2. 获取用户信息（跨模块调用）
        if let userModule = ModuleManager.shared.module(UserModule.self) {
            if let user = userModule.getCurrentUser() {
                print("当前用户：\(user.name)")
            }
        }
    }
    
    @objc func buyButtonTapped() {
        // 3. 检查登录状态（跨模块调用）
        if let userModule = ModuleManager.shared.module(UserModule.self) {
            if userModule.getCurrentUser() != nil {
                // 已登录，添加到购物车
                addToCart()
            } else {
                // 未登录，跳转登录页
                ModuleManager.shared.openPage(
                    UserModule.self,
                    parameters: [:],
                    from: self
                )
            }
        }
    }
}
```

---

## 🔄 与现有 URL Router 共存

### 方案：两种路由互补使用

```swift
/// 统一路由入口
class UnifiedRouter {
    
    /// 打开页面（自动选择路由方式）
    static func open(
        _ target: Any,
        parameters: [String: Any] = [:],
        from source: UIViewController? = nil
    ) -> Bool {
        
        // 方式1：URL 字符串 → URL-Based Router
        if let urlString = target as? String {
            return Router.shared.open(urlString, parameters: parameters, from: source)
        }
        
        // 方式2：模块类型 → Protocol-Based Router
        if let moduleType = target as? PageModuleProtocol.Type {
            return ModuleManager.shared.openPage(
                moduleType,
                parameters: parameters,
                from: source
            )
        }
        
        return false
    }
}

// 使用示例
UnifiedRouter.open("app://user/123")  // URL Router
UnifiedRouter.open(UserModule.self, parameters: ["userId": "123"])  // Protocol Router
```

---

## 📊 方案对比总结

### URL-Based Router

**适用场景：**
- ✅ 外部唤起（URL Scheme、Universal Links）
- ✅ H5 交互（WebView 跳转）
- ✅ 推送通知跳转
- ✅ 运营配置（远程下发 URL）
- ✅ 动态路由

**示例：**
```swift
Router.shared.open("app://product/123?name=iPhone")
```

---

### Protocol-Based Router

**适用场景：**
- ✅ 应用内模块跳转
- ✅ 服务调用（模块间通信）
- ✅ 类型安全要求高
- ✅ 大型项目组件化
- ✅ 需要编译检查

**示例：**
```swift
// 页面跳转
ModuleManager.shared.openPage(UserModule.self, parameters: ["userId": "123"])

// 服务调用
userModule.login(username: "zhangsan", password: "123")
```

---

## 🎯 最佳实践

### 1. 选择合适的路由方式

```swift
// ✅ 外部唤起：使用 URL Router
Router.shared.open("myapp://product/123")

// ✅ 应用内跳转：使用 Protocol Router（类型安全）
ModuleManager.shared.openPage(ProductModule.self, parameters: ["productId": "123"])

// ✅ 服务调用：使用 Protocol Router
let user = userModule.getCurrentUser()
```

### 2. 模块协议设计

```swift
protocol UserModuleProtocol: PageModuleProtocol, ServiceModuleProtocol {
    // 页面相关
    func createUserDetailPage(userId: String) -> UIViewController?
    
    // 服务相关
    func getCurrentUser() -> User?
    func login(...) -> Bool
}
```

### 3. 模块独立性

```swift
// ✅ 好：通过协议调用
if let userModule = ModuleManager.shared.module(UserModule.self) {
    let user = userModule.getCurrentUser()
}

// ❌ 差：直接依赖模块
import UserModule  // 紧耦合
let user = UserManager.shared.getCurrentUser()
```

---

## 💡 组件化架构示例

### 项目结构

```
MyApp/
├── App/                    # 主工程
│   ├── AppDelegate.swift
│   └── ModuleRegister.swift
│
├── Protocols/              # 协议层
│   ├── UserModuleProtocol.swift
│   ├── ProductModuleProtocol.swift
│   └── OrderModuleProtocol.swift
│
├── UserModule/             # 用户模块
│   ├── UserModule.swift
│   ├── UserDetailViewController.swift
│   └── UserListViewController.swift
│
├── ProductModule/          # 商品模块
│   ├── ProductModule.swift
│   ├── ProductDetailViewController.swift
│   └── ProductListViewController.swift
│
└── OrderModule/            # 订单模块
    ├── OrderModule.swift
    └── OrderListViewController.swift
```

---

## 🔍 高级特性

### 1. 依赖注入

```swift
protocol NetworkServiceProtocol {
    func request(url: String, completion: @escaping (Data?) -> Void)
}

class ProductModule: ProductModuleProtocol {
    var networkService: NetworkServiceProtocol?
    
    func getProduct(productId: String, completion: @escaping (Product?) -> Void) {
        // 使用注入的网络服务
        networkService?.request(url: "/products/\(productId)") { data in
            // 处理数据
        }
    }
}
```

### 2. 模块生命周期

```swift
protocol ModuleLifecycleProtocol {
    func moduleDidLoad()
    func moduleWillAppear()
    func moduleDidDisappear()
}
```

### 3. 模块间通知

```swift
class ModuleNotificationCenter {
    static let shared = ModuleNotificationCenter()
    
    func post(event: String, data: [String: Any]) {
        // 跨模块通知
    }
    
    func addObserver(event: String, handler: @escaping ([String: Any]) -> Void) {
        // 监听通知
    }
}
```

---

## ✅ 总结

### 两种路由对比

| 特性 | URL-Based | Protocol-Based |
|------|-----------|----------------|
| 类型安全 | ❌ | ✅ |
| 编译检查 | ❌ | ✅ |
| 外部唤起 | ✅ | ❌ |
| 服务调用 | ❌ | ✅ |
| 动态配置 | ✅ | ❌ |
| 适合场景 | 外部交互 | 内部通信 |

### 推荐使用

**大型项目：两种路由结合使用**

- **URL Router** → 外部唤起、H5交互、推送通知
- **Protocol Router** → 应用内跳转、模块通信、服务调用

**小型项目：单一路由即可**

- URL Router 更灵活
- Protocol Router 更安全

---

**接下来我将实现完整的代码！🚀**

