# 模块间通信完整方案

## 📌 核心理念

在 Protocol-Based Router 中，**模块通过 ModuleManager（中介者）进行通信**，而不是直接依赖对方，实现完全解耦。

---

## 💻 通信方式

### 方式 1：通过 ModuleManager 调用服务（推荐⭐⭐⭐⭐⭐）

这是**最推荐**的方式，通过中介者模式，模块间完全解耦。

#### 场景 1：ProductModule 调用 UserModule 服务

```swift
// ProductDetailViewController.swift（商品详情页）

class ProductDetailViewController: UIViewController {
    var productId: String?
    
    @IBAction func buyButtonTapped() {
        // 1. 获取 UserModule
        guard let userModule = ModuleManager.shared.module(UserModule.self) else {
            print("❌ 获取 UserModule 失败")
            return
        }
        
        // 2. 检查登录状态（调用 UserModule 服务）
        if let user = userModule.getCurrentUser() {
            // 已登录，可以购买
            print("✅ 用户已登录：\(user.name)")
            processPurchase()
        } else {
            // 未登录，跳转登录页
            print("⚠️ 用户未登录，跳转登录页")
            
            // 3. 打开登录页（UserModule 提供的页面）
            ModuleManager.shared.openPage(
                UserModule.self,
                parameters: ["isLogin": true],
                from: self
            )
        }
    }
    
    private func processPurchase() {
        // 获取 ProductModule，调用购买服务
        if let productModule = ModuleManager.shared.module(ProductModule.self) {
            productModule.addToCart(productId: productId ?? "", quantity: 1)
            print("✅ 已添加到购物车")
        }
    }
}
```

#### 场景 2：UserModule 登录后通知 ProductModule

```swift
// ModuleLoginViewController.swift（登录页）

class ModuleLoginViewController: UIViewController {
    
    @objc private func loginTapped() {
        let username = usernameTextField.text ?? ""
        let password = passwordTextField.text ?? ""
        
        // 1. 调用 UserModule 登录服务
        if let userModule = ModuleManager.shared.module(UserModule.self) {
            userModule.login(username: username, password: password) { [weak self] success, error in
                if success {
                    print("✅ 登录成功")
                    
                    // 2. 登录成功后，可以调用其他模块服务
                    // 例如：同步购物车
                    if let productModule = ModuleManager.shared.module(ProductModule.self) {
                        productModule.syncCart()
                    }
                    
                    // 3. 返回上一页
                    self?.navigationController?.popViewController(animated: true)
                }
            }
        }
    }
}
```

---

### 方式 2：通过协议定义依赖关系

#### 定义模块间依赖协议

```swift
// ProductModuleProtocol.swift

protocol ProductModuleProtocol: PageModuleProtocol, ServiceModuleProtocol {
    // ... 商品相关服务
    
    /// 设置用户模块依赖（可选）
    var userModule: UserModuleProtocol? { get set }
}

// ProductModule.swift

class ProductModule: ProductModuleProtocol {
    static let moduleName = "ProductModule"
    
    // 依赖的其他模块（可选）
    var userModule: UserModuleProtocol?
    
    required init() {
        // 自动注入依赖（可选）
        self.userModule = ModuleManager.shared.module(UserModule.self)
    }
    
    func addToCart(productId: String, quantity: Int) -> Bool {
        // 检查登录状态（使用注入的 userModule）
        if let user = userModule?.getCurrentUser() {
            print("✅ 用户 \(user.name) 添加商品到购物车")
            // 添加到购物车逻辑
            return true
        } else {
            print("❌ 用户未登录，无法添加到购物车")
            return false
        }
    }
}
```

---

### 方式 3：通过通知中心（观察者模式）

适用于**一对多**的通信场景。

#### 定义模块通知

```swift
// ModuleNotification.swift

extension Notification.Name {
    // 用户相关通知
    static let userDidLogin = Notification.Name("userDidLogin")
    static let userDidLogout = Notification.Name("userDidLogout")
    static let userInfoDidUpdate = Notification.Name("userInfoDidUpdate")
    
    // 商品相关通知
    static let productDidAddToCart = Notification.Name("productDidAddToCart")
    static let cartDidUpdate = Notification.Name("cartDidUpdate")
}

// 通知数据
struct UserLoginNotification {
    let user: User
    let timestamp: Date
}
```

#### UserModule 发送通知

```swift
// UserModule.swift

class UserModule: UserModuleProtocol {
    
    func login(username: String, password: String, completion: @escaping (Bool, String?) -> Void) {
        // 登录逻辑...
        
        if success {
            currentUser = user
            
            // 发送登录成功通知
            let userInfo = ["user": user, "timestamp": Date()] as [String: Any]
            NotificationCenter.default.post(
                name: .userDidLogin,
                object: nil,
                userInfo: userInfo
            )
            
            completion(true, nil)
        }
    }
    
    func logout() {
        currentUser = nil
        
        // 发送登出通知
        NotificationCenter.default.post(name: .userDidLogout, object: nil)
        
        print("🔓 已登出")
    }
}
```

#### ProductModule 监听通知

```swift
// ProductModule.swift

class ProductModule: ProductModuleProtocol {
    static let moduleName = "ProductModule"
    
    required init() {
        setupNotificationObservers()
    }
    
    private func setupNotificationObservers() {
        // 监听用户登录通知
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleUserLogin(_:)),
            name: .userDidLogin,
            object: nil
        )
        
        // 监听用户登出通知
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleUserLogout(_:)),
            name: .userDidLogout,
            object: nil
        )
    }
    
    @objc private func handleUserLogin(_ notification: Notification) {
        if let user = notification.userInfo?["user"] as? User {
            print("📦 ProductModule 收到登录通知：\(user.name)")
            
            // 同步购物车
            syncCart()
        }
    }
    
    @objc private func handleUserLogout(_ notification: Notification) {
        print("📦 ProductModule 收到登出通知")
        
        // 清空购物车
        clearCart()
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
}
```

---

### 方式 4：通过 EventBus（发布订阅）

如果项目中已经有 EventBus，可以使用它进行模块间通信。

```swift
// 定义事件
struct UserLoginEvent {
    let user: User
    let loginTime: Date
}

struct CartUpdateEvent {
    let productId: String
    let quantity: Int
}

// UserModule 发布事件
class UserModule: UserModuleProtocol {
    func login(username: String, password: String, completion: @escaping (Bool, String?) -> Void) {
        // 登录成功
        if success {
            // 发布登录事件
            EventBus.shared.post(UserLoginEvent(user: user, loginTime: Date()))
            completion(true, nil)
        }
    }
}

// ProductModule 订阅事件
class ProductModule: ProductModuleProtocol {
    required init() {
        // 订阅用户登录事件
        EventBus.shared.subscribe(UserLoginEvent.self) { [weak self] event in
            print("📦 ProductModule 收到登录事件：\(event.user.name)")
            self?.syncCart()
        }
    }
}
```

---

## 🎯 完整通信示例

### 场景：商品详情页购买流程

```swift
// 1. 商品详情页（ProductDetailViewController）

class ProductDetailViewController: UIViewController {
    var productId: String = "8888"
    var product: Product?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        loadProduct()
    }
    
    // 加载商品信息
    private func loadProduct() {
        // 调用 ProductModule 服务
        if let productModule = ModuleManager.shared.module(ProductModule.self) {
            productModule.getProduct(productId: productId) { [weak self] product in
                self?.product = product
                self?.updateUI()
            }
        }
    }
    
    // 点击购买按钮
    @IBAction func buyButtonTapped() {
        // 步骤1：检查登录状态（调用 UserModule）
        checkLoginAndPurchase()
    }
    
    private func checkLoginAndPurchase() {
        // 获取 UserModule
        guard let userModule = ModuleManager.shared.module(UserModule.self) else {
            showAlert("系统错误：无法获取用户模块")
            return
        }
        
        // 检查是否登录
        if let user = userModule.getCurrentUser() {
            // 已登录，继续购买流程
            print("✅ 用户已登录：\(user.name)")
            confirmPurchase(user: user)
        } else {
            // 未登录，跳转登录页
            print("⚠️ 用户未登录")
            openLoginPage()
        }
    }
    
    private func openLoginPage() {
        // 打开登录页（UserModule 提供）
        ModuleManager.shared.openPage(
            UserModule.self,
            parameters: ["isLogin": true],
            from: self
        )
    }
    
    private func confirmPurchase(user: User) {
        let alert = UIAlertController(
            title: "确认购买",
            message: "确定购买 \(product?.name ?? "") 吗？",
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "取消", style: .cancel))
        alert.addAction(UIAlertAction(title: "确定", style: .default) { [weak self] _ in
            self?.processPurchase()
        })
        
        present(alert, animated: true)
    }
    
    private func processPurchase() {
        // 步骤2：添加到购物车（调用 ProductModule）
        guard let productModule = ModuleManager.shared.module(ProductModule.self) else {
            showAlert("系统错误：无法获取商品模块")
            return
        }
        
        let success = productModule.addToCart(productId: productId, quantity: 1)
        
        if success {
            showAlert("✅ 已添加到购物车") {
                // 步骤3：跳转到购物车页面（可选）
                // 这里可以再调用 OrderModule 等
            }
        } else {
            showAlert("❌ 添加失败")
        }
    }
    
    private func showAlert(_ message: String, completion: (() -> Void)? = nil) {
        let alert = UIAlertController(title: nil, message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "确定", style: .default) { _ in
            completion?()
        })
        present(alert, animated: true)
    }
}
```

### 场景：用户登录后同步数据

```swift
// 2. 登录页（ModuleLoginViewController）

class ModuleLoginViewController: UIViewController {
    
    @objc private func loginTapped() {
        let username = usernameTextField.text ?? ""
        let password = passwordTextField.text ?? ""
        
        // 调用 UserModule 登录
        guard let userModule = ModuleManager.shared.module(UserModule.self) else {
            return
        }
        
        statusLabel.text = "登录中..."
        
        userModule.login(username: username, password: password) { [weak self] success, error in
            if success {
                self?.statusLabel.text = "✅ 登录成功"
                
                // 登录成功后的操作
                self?.afterLoginSuccess()
                
                // 1秒后返回
                DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                    self?.navigationController?.popViewController(animated: true)
                }
            } else {
                self?.statusLabel.text = "❌ \(error ?? "登录失败")"
            }
        }
    }
    
    private func afterLoginSuccess() {
        // 1. 同步购物车（调用 ProductModule）
        if let productModule = ModuleManager.shared.module(ProductModule.self) {
            productModule.syncCart()
        }
        
        // 2. 同步订单（调用 OrderModule）
        // if let orderModule = ModuleManager.shared.module(OrderModule.self) {
        //     orderModule.syncOrders()
        // }
        
        // 3. 发送通知（通知其他模块）
        NotificationCenter.default.post(name: .userDidLogin, object: nil)
    }
}
```

---

## 🔄 通信流程图

### 场景：商品购买流程

```
┌──────────────────────────────────────────┐
│         商品详情页                        │
│    (ProductDetailViewController)         │
└──────────────────────────────────────────┘
                 ↓
         点击 [购买] 按钮
                 ↓
┌──────────────────────────────────────────┐
│    获取 UserModule                        │
│    ModuleManager.shared.module(...)       │
└──────────────────────────────────────────┘
                 ↓
         检查登录状态
                 ↓
        ┌────────┴────────┐
        ↓                 ↓
    已登录            未登录
        ↓                 ↓
    继续购买      打开登录页 (UserModule)
        ↓                 ↓
    添加购物车       用户输入账号密码
        ↓                 ↓
    调用              调用 UserModule.login()
ProductModule             ↓
    ↓                 登录成功
    ↓                 ↓
    ↓            发送通知/EventBus
    ↓                 ↓
    ↓            ProductModule 同步数据
    ↓                 ↓
    └────────┬────────┘
             ↓
        购买完成
```

---

## 📊 方式对比

| 通信方式 | 优点 | 缺点 | 适用场景 |
|---------|------|------|---------|
| **ModuleManager 调用** | ✅ 类型安全<br>✅ 编译检查<br>✅ 灵活 | ❌ 需要获取模块实例 | ⭐⭐⭐⭐⭐<br>最推荐，所有场景 |
| **协议依赖注入** | ✅ 更清晰的依赖关系<br>✅ 易于测试 | ❌ 需要显式声明依赖 | ⭐⭐⭐⭐<br>复杂依赖场景 |
| **NotificationCenter** | ✅ 一对多广播<br>✅ 解耦 | ❌ 无类型安全<br>❌ 难以追踪 | ⭐⭐⭐<br>广播通知场景 |
| **EventBus** | ✅ 类型安全<br>✅ 一对多 | ❌ 需要引入 EventBus | ⭐⭐⭐⭐<br>事件驱动场景 |

---

## 💡 最佳实践

### 1. 优先使用 ModuleManager（推荐）

```swift
// ✅ 推荐：通过 ModuleManager 调用
if let userModule = ModuleManager.shared.module(UserModule.self) {
    let user = userModule.getCurrentUser()
}

// ❌ 避免：直接依赖模块
import UserModule  // 紧耦合
let user = UserManager.shared.getCurrentUser()
```

### 2. 服务调用 vs 通知

```swift
// 服务调用：需要返回值或同步操作
let user = userModule.getCurrentUser()  // ✅ 立即返回

// 通知：异步通知，不需要返回值
NotificationCenter.default.post(name: .userDidLogin, object: nil)  // ✅ 广播
```

### 3. 错误处理

```swift
// 检查模块是否存在
guard let userModule = ModuleManager.shared.module(UserModule.self) else {
    print("❌ UserModule 未注册")
    return
}

// 检查服务返回值
if let user = userModule.getCurrentUser() {
    // 已登录
} else {
    // 未登录
}
```

### 4. 避免循环依赖

```swift
// ❌ 避免循环依赖
UserModule → ProductModule → OrderModule → UserModule  // 循环

// ✅ 单向依赖
UserModule ← ProductModule ← OrderModule  // 单向
```

---

## 🎯 完整代码示例

### ProductModule 调用 UserModule

```swift
// ProductModule.swift

class ProductModule: ProductModuleProtocol {
    static let moduleName = "ProductModule"
    
    required init() {}
    
    // 添加到购物车（需要检查登录）
    func addToCart(productId: String, quantity: Int) -> Bool {
        // 1. 获取 UserModule
        guard let userModule = ModuleManager.shared.module(UserModule.self) else {
            print("❌ 无法获取 UserModule")
            return false
        }
        
        // 2. 检查登录状态
        guard let user = userModule.getCurrentUser() else {
            print("❌ 用户未登录")
            return false
        }
        
        // 3. 添加到购物车
        print("✅ 用户 \(user.name) 添加商品 \(productId) x\(quantity)")
        
        // 4. 保存到本地或服务器
        // ...
        
        return true
    }
    
    // 同步购物车（登录后调用）
    func syncCart() {
        print("🔄 同步购物车...")
        
        // 获取用户信息
        if let userModule = ModuleManager.shared.module(UserModule.self),
           let user = userModule.getCurrentUser() {
            print("✅ 为用户 \(user.name) 同步购物车")
            
            // 从服务器获取购物车数据
            // ...
        }
    }
}
```

### UserModule 通知其他模块

```swift
// UserModule.swift

class UserModule: UserModuleProtocol {
    static let moduleName = "UserModule"
    
    private var currentUser: User?
    
    required init() {}
    
    func login(username: String, password: String, completion: @escaping (Bool, String?) -> Void) {
        print("🔐 登录：\(username)")
        
        // 模拟网络请求
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) { [weak self] in
            // 登录成功
            self?.currentUser = User(
                id: "123",
                name: username,
                avatar: nil,
                email: "\(username)@example.com"
            )
            
            // 通知其他模块
            self?.notifyLoginSuccess()
            
            completion(true, nil)
        }
    }
    
    private func notifyLoginSuccess() {
        // 方式1：通过通知中心
        NotificationCenter.default.post(name: .userDidLogin, object: currentUser)
        
        // 方式2：直接调用其他模块服务
        // 同步购物车
        if let productModule = ModuleManager.shared.module(ProductModule.self) {
            productModule.syncCart()
        }
        
        // 同步订单
        // if let orderModule = ModuleManager.shared.module(OrderModule.self) {
        //     orderModule.syncOrders()
        // }
    }
    
    func logout() {
        currentUser = nil
        
        // 通知其他模块
        NotificationCenter.default.post(name: .userDidLogout, object: nil)
        
        // 清空其他模块数据
        if let productModule = ModuleManager.shared.module(ProductModule.self) {
            productModule.clearCart()
        }
        
        print("🔓 已登出")
    }
    
    func getCurrentUser() -> User? {
        return currentUser
    }
}
```

---

## ✅ 总结

### 模块间通信的核心原则

1. **通过 ModuleManager 调用** - 最推荐 ⭐⭐⭐⭐⭐
2. **协议定义接口** - 类型安全
3. **单向依赖** - 避免循环
4. **通知广播** - 一对多场景

### 通信示例

```swift
// ProductModule 需要 UserModule 服务
if let userModule = ModuleManager.shared.module(UserModule.self) {
    if userModule.isLoggedIn() {
        // 已登录，继续操作
    } else {
        // 未登录，打开登录页
        ModuleManager.shared.openPage(UserModule.self, parameters: ["isLogin": true])
    }
}
```

### 核心优势

✅ **完全解耦** - 模块间不直接依赖  
✅ **类型安全** - 编译时检查  
✅ **灵活** - 支持多种通信方式  
✅ **易于测试** - 可 Mock 模块  

---

**模块间通信已完整实现，立即测试跨模块功能！🚀**

