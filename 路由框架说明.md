# 路由框架 - URL-Based Router

## 📦 功能概述

实现了一个完整的 **URL-Based 路由框架**，解决 iOS 应用中**模块间页面跳转解耦**的问题，支持动态路由、参数传递、拦截器等功能。

---

## ✨ 核心特性

### 1. **URL 模式匹配**
```
支持占位符：
app://user/:userId          →  app://user/123
app://product/:id/detail    →  app://product/456/detail

支持 Query 参数：
app://search?keyword=iPhone&page=1
```

### 2. **多种跳转方式**
- ✅ **Push** - 导航栏 push
- ✅ **Present** - 模态弹出
- ✅ **Replace** - 替换当前页面
- ✅ **Custom** - 自定义跳转方式

### 3. **参数传递**
- ✅ **路径参数** - `/user/:userId` → `userId=123`
- ✅ **Query 参数** - `?name=张三&age=25`
- ✅ **额外参数** - 代码中传递的 Dictionary

### 4. **拦截器（中间件）**
- ✅ 登录验证
- ✅ 权限检查
- ✅ 埋点统计
- ✅ 参数校验

### 5. **协议解耦**
- ✅ Routable 协议
- ✅ 自动实例化 ViewController
- ✅ 模块间零耦合

---

## 🏗️ 架构设计

### 核心组件

```
┌─────────────────────────────────────┐
│            Router（单例）            │
│       - 路由表管理                   │
│       - URL 匹配                     │
│       - 跳转执行                     │
│       - 拦截器管理                   │
└──────────────┬──────────────────────┘
               │
    ┌──────────┴──────────┐
    │                     │
┌───▼────────┐    ┌───────▼──────┐
│ RouteInfo  │    │ RouteRequest │
│ - pattern  │    │ - url        │
│ - action   │    │ - parameters │
│ - handler  │    │ - source     │
└────────────┘    └──────────────┘
               │
    ┌──────────┴──────────┐
    │                     │
┌───▼────────┐    ┌───────▼──────┐
│  Routable  │    │ Interceptor  │
│  协议      │    │ 拦截器       │
└────────────┘    └──────────────┘
```

### 路由匹配流程

```
  输入 URL：app://user/123?name=张三
         │
    ┌────▼─────┐
    │ 解析 URL │
    └────┬─────┘
         │
  ┌──────▼────────┐
  │ 匹配路由表    │
  │ app://user/:userId │
  └──────┬────────┘
         │
  ┌──────▼────────┐
  │ 提取参数      │
  │ userId = 123  │
  │ name = 张三   │
  └──────┬────────┘
         │
  ┌──────▼────────┐
  │ 执行拦截器    │
  └──────┬────────┘
         │
  ┌──────▼────────┐
  │ 创建 VC       │
  └──────┬────────┘
         │
  ┌──────▼────────┐
  │ 执行跳转      │
  │ (push/present)│
  └───────────────┘
```

---

## 💻 使用方法

### 1. 注册路由（AppDelegate）

```swift
import UIKit

func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
    
    // 注册路由
    registerRoutes()
    
    return true
}

func registerRoutes() {
    let router = Router.shared
    
    // 方式1：使用 Routable 协议（推荐）
    router.register(
        "app://user/:userId",
        viewControllerType: UserDetailViewController.self,
        action: .push
    )
    
    // 方式2：使用闭包
    router.register("app://product/:productId", action: .push) { parameters in
        let vc = ProductDetailViewController()
        vc.productId = parameters["productId"] as? String
        return vc
    }
    
    // 方式3：模态弹出
    router.register("app://settings", action: .present) { _ in
        let vc = SettingsViewController()
        return UINavigationController(rootViewController: vc)
    }
}
```

### 2. ViewController 实现 Routable 协议

```swift
class UserDetailViewController: UIViewController, Routable {
    
    var userId: String?
    var userName: String?
    
    // MARK: - Routable 协议
    
    static func instantiate(with parameters: [String: Any]) -> Self? {
        let vc = Self()
        vc.userId = parameters["userId"] as? String
        vc.userName = parameters["name"] as? String
        return vc
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        title = "用户详情"
        print("用户ID：\(userId ?? "")")
        print("用户名：\(userName ?? "")")
    }
}
```

### 3. 打开页面

```swift
// 方式1：基本使用
Router.shared.open("app://user/123")

// 方式2：带额外参数
Router.shared.open("app://user/123", parameters: ["name": "张三", "age": 25])

// 方式3：带 Query 参数
Router.shared.open("app://product/456?name=iPhone&price=5999")

// 方式4：指定源 ViewController
Router.shared.open("app://settings", from: self)

// 方式5：带完成回调
Router.shared.open("app://user/123") {
    print("页面已打开")
}

// 方式6：UIViewController 扩展（更简洁）
self.open("app://user/123")
self.open("app://product/456", parameters: ["name": "iPhone"])
```

### 4. 返回和关闭

```swift
// 返回上一页
Router.shared.open("app://back")
self.routeBack()

// 关闭模态
Router.shared.open("app://dismiss")
self.routeDismiss()
```

### 5. 添加拦截器（中间件）

```swift
// 登录验证拦截器
Router.shared.addInterceptor { request in
    // 需要登录的页面
    let needsLogin = request.url.absoluteString.contains("/user/")
    
    if needsLogin {
        let isLoggedIn = UserDefaults.standard.bool(forKey: "isLoggedIn")
        
        if !isLoggedIn {
            print("⛔ 需要登录")
            // 跳转到登录页
            Router.shared.open("app://login")
            return false  // 拦截
        }
    }
    
    return true  // 通过
}

// 埋点统计拦截器
Router.shared.addInterceptor { request in
    print("📊 统计：打开页面 \(request.url)")
    // 发送埋点数据...
    return true
}

// 参数校验拦截器
Router.shared.addInterceptor { request in
    if request.url.path.contains("/product/") {
        guard let productId = request.parameters["productId"] as? String,
              !productId.isEmpty else {
            print("❌ 商品ID不能为空")
            return false
        }
    }
    return true
}
```

### 6. 处理外部 URL

```swift
// AppDelegate / SceneDelegate

// 方式1：URL Scheme
func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
    // myapp://user/123
    return Router.shared.open(url)
}

// 方式2：Universal Links（通用链接）
func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
    
    if userActivity.activityType == NSUserActivityTypeBrowsingWeb,
       let url = userActivity.webpageURL {
        // https://www.myapp.com/user/123
        // 需要转换为内部路由格式
        let internalURL = convertToInternalURL(url)
        return Router.shared.open(internalURL)
    }
    
    return false
}

func convertToInternalURL(_ externalURL: URL) -> URL {
    // https://www.myapp.com/user/123 → app://user/123
    var components = URLComponents(url: externalURL, resolvingAgainstBaseURL: false)
    components?.scheme = "app"
    components?.host = nil
    return components?.url ?? externalURL
}
```

### 7. 动态注册和注销

```swift
// 动态注册（例如：某个功能模块加载后）
Router.shared.register("app://premium/:featureId") { parameters in
    return PremiumFeatureViewController.instantiate(with: parameters)
}

// 注销路由（例如：功能下线）
Router.shared.unregister("app://premium/:featureId")
```

---

## 🎯 核心技术实现

### 1. URL 模式匹配

```swift
// 输入：
urlPath = "/user/123"
patternPath = "/user/:userId"

// 匹配逻辑：
let urlComponents = ["/", "user", "123"]
let patternComponents = ["/", "user", ":userId"]

// 遍历比较：
for (urlComp, patternComp) in zip(urlComponents, patternComponents) {
    if patternComp.hasPrefix(":") {
        // 参数占位符，提取参数
        let key = "userId"
        parameters[key] = "123"
    } else if urlComp != patternComp {
        // 不匹配
        return nil
    }
}

// 结果：
parameters = ["userId": "123"]
```

### 2. 参数合并

```swift
// 三种参数来源：
1. 路径参数：/user/:userId → ["userId": "123"]
2. Query 参数：?name=张三&age=25 → ["name": "张三", "age": 25]
3. 代码参数：parameters: ["vip": true]

// 合并策略（后者覆盖前者）：
var allParameters = pathParameters
allParameters.merge(queryParameters) { $1 }  // Query 覆盖 Path
allParameters.merge(codeParameters) { $1 }   // Code 覆盖 Query

// 最终参数：
["userId": "123", "name": "张三", "age": 25, "vip": true]
```

### 3. 获取当前 ViewController

```swift
// 递归查找当前显示的 ViewController
func currentViewController() -> UIViewController? {
    guard let window = keyWindow,
          let root = window.rootViewController else {
        return nil
    }
    
    return findCurrent(from: root)
}

func findCurrent(from vc: UIViewController) -> UIViewController {
    // 1. 如果有 presented，优先返回
    if let presented = vc.presentedViewController {
        return findCurrent(from: presented)
    }
    
    // 2. NavigationController
    if let nav = vc as? UINavigationController {
        if let visible = nav.visibleViewController {
            return findCurrent(from: visible)
        }
    }
    
    // 3. TabBarController
    if let tab = vc as? UITabBarController {
        if let selected = tab.selectedViewController {
            return findCurrent(from: selected)
        }
    }
    
    return vc
}
```

### 4. Routable 协议

```swift
protocol Routable {
    static func instantiate(with parameters: [String: Any]) -> Self?
}

// 好处：
// ✅ 统一的实例化接口
// ✅ 参数自动传递
// ✅ 类型安全
// ✅ 解耦

// 使用：
router.register(
    "app://user/:userId",
    viewControllerType: UserDetailViewController.self  // 传递类型即可
)
```

---

## 📊 优势分析

### vs 传统跳转方式

| 对比项 | 传统方式 | 路由方式 |
|--------|---------|---------|
| 耦合度 | 高（直接依赖类） | 低（通过 URL） |
| 模块化 | 困难 | 容易 |
| 外部唤起 | 复杂 | 简单 |
| 参数传递 | 手动 | 自动 |
| 统一管理 | 分散 | 集中 |
| 埋点统计 | 分散 | 统一 |
| 权限控制 | 分散 | 统一 |

### 传统方式

```swift
// ❌ 问题1：紧耦合
import UserModule  // 依赖其他模块

let vc = UserDetailViewController()  // 直接创建
vc.userId = "123"
navigationController?.pushViewController(vc, animated: true)

// ❌ 问题2：外部唤起困难
// 需要在 AppDelegate 中写大量 if-else

// ❌ 问题3：权限控制分散
// 每个页面都要检查权限

// ❌ 问题4：埋点分散
// 每个页面跳转都要手动埋点
```

### 路由方式

```swift
// ✅ 优点1：解耦
Router.shared.open("app://user/123")  // 无需 import

// ✅ 优点2：外部唤起简单
func application(_ app: UIApplication, open url: URL) -> Bool {
    return Router.shared.open(url)  // 一行代码
}

// ✅ 优点3：统一权限控制
Router.shared.addInterceptor { request in
    // 统一检查权限
    return checkPermission(request.url)
}

// ✅ 优点4：统一埋点
Router.shared.addInterceptor { request in
    // 统一埋点
    Analytics.track("page_view", url: request.url)
    return true
}
```

---

## 🎤 面试要点

### 1. 为什么需要路由？

```
问题背景：
- 模块间页面跳转紧耦合
- 外部 URL 唤起复杂
- 权限控制、埋点统计分散
- 组件化、模块化困难

解决方案：
- 路由层解耦（通过 URL）
- 统一跳转入口
- 拦截器统一处理
- 支持动态注册
```

### 2. URL-Based vs Protocol-Based？

```swift
// URL-Based（本框架）
Router.shared.open("app://user/123")

优点：
✅ 支持外部唤起（URL Scheme / Universal Links）
✅ 支持动态路由（运行时注册）
✅ 字符串传递，跨语言、跨平台
✅ 配置化（可从服务器下发路由表）

缺点：
❌ 类型不安全（字符串）
❌ 编译时无法检查错误
❌ 参数传递受限（只能是基本类型）

// Protocol-Based
let navigator = container.resolve(UserNavigator.self)
navigator.navigateToUserDetail(userId: "123", user: userObject)

优点：
✅ 类型安全
✅ 编译时检查
✅ 支持复杂对象传递
✅ IDE 自动补全

缺点：
❌ 不支持外部唤起
❌ 模块间仍有依赖（协议）
❌ 不够灵活

实际项目：
通常结合使用，URL-Based 处理外部唤起和简单跳转，
Protocol-Based 处理复杂业务跳转。
```

### 3. 如何设计 URL 模式？

```
1. 遵循 RESTful 风格
   ✅ app://user/:userId
   ✅ app://product/:productId/detail
   ❌ app://showUser?id=123

2. 清晰的层级结构
   ✅ app://shop/product/:id
   ✅ app://shop/category/:categoryId/product/:id

3. 保留关键字
   ✅ app://back
   ✅ app://dismiss
   ✅ app://home

4. 版本控制（可选）
   ✅ app://v1/user/:userId
   ✅ app://v2/user/:userId  // 新版本
```

### 4. 拦截器的执行顺序？

```swift
// 按注册顺序执行
Router.shared.addInterceptor(interceptor1)  // 先执行
Router.shared.addInterceptor(interceptor2)  // 后执行

// 任何一个返回 false，终止后续执行
interceptor1 → true  → 继续
interceptor2 → false → 终止，不跳转
interceptor3 → （不执行）

// 常见顺序：
1. 参数校验
2. 权限检查
3. 登录验证
4. 埋点统计
```

### 5. 如何处理参数传递？

```swift
// 简单参数：通过 URL
Router.shared.open("app://user/123?name=张三")

// 复杂对象：通过 parameters
let user = User(...)
Router.shared.open("app://user/123", parameters: ["user": user])

// 目标页面：
class UserDetailViewController: UIViewController, Routable {
    static func instantiate(with parameters: [String: Any]) -> Self? {
        let vc = Self()
        vc.userId = parameters["userId"] as? String
        vc.user = parameters["user"] as? User  // 复杂对象
        return vc
    }
}

// 注意事项：
// ⚠️ 外部 URL 只能传递基本类型（String, Int, Bool）
// ⚠️ 复杂对象只能在 App 内部传递
```

### 6. 如何测试路由？

```swift
// 单元测试
func testRouteMatching() {
    let router = Router.shared
    router.register("app://user/:userId", viewControllerType: UserDetailViewController.self)
    
    // 测试匹配
    let result = router.open("app://user/123")
    XCTAssertTrue(result)
}

// UI 测试
func testUserDetailNavigation() {
    let app = XCUIApplication()
    app.buttons["打开用户详情"].tap()
    
    // 验证页面跳转
    XCTAssertTrue(app.navigationBars["用户详情"].exists)
}
```

---

## 🚀 扩展方向

### 短期扩展

1. **路由表配置化**
   ```swift
   // 从 JSON 文件或服务器加载路由表
   {
     "routes": [
       {
         "pattern": "app://user/:userId",
         "class": "UserDetailViewController",
         "action": "push"
       }
     ]
   }
   ```

2. **路由别名**
   ```swift
   router.registerAlias("userDetail", for: "app://user/:userId")
   router.open(alias: "userDetail", parameters: ["userId": "123"])
   ```

3. **路由日志**
   ```swift
   // 记录所有路由跳转
   router.enableLogging()
   ```

### 中期扩展

4. **路由动画**
   ```swift
   router.register("app://user/:userId", transition: .custom {
       // 自定义转场动画
   })
   ```

5. **路由回调**
   ```swift
   // 页面返回时回调
   router.open("app://edit", onDismiss: { result in
       print("编辑完成：\(result)")
   })
   ```

6. **路由优先级**
   ```swift
   // 同一个 URL，注册多个处理器，按优先级执行
   router.register("app://share", priority: .high) { ... }
   router.register("app://share", priority: .low) { ... }
   ```

### 长期扩展

7. **跨平台路由**
   ```swift
   // 统一 iOS/Android 路由规则
   // H5 也可以通过相同 URL 跳转
   ```

8. **A/B 测试**
   ```swift
   // 根据实验分组，跳转到不同页面
   router.register("app://user/:userId") { parameters in
       if ABTest.group == "A" {
           return UserDetailViewControllerA()
       } else {
           return UserDetailViewControllerB()
       }
   }
   ```

---

## 💡 总结

### 实现的功能

✅ URL 模式匹配（支持占位符）  
✅ 多种跳转方式（push/present/replace/custom）  
✅ 参数传递（路径/Query/代码）  
✅ 拦截器（中间件）  
✅ Routable 协议  
✅ 动态注册和注销  
✅ 获取当前 ViewController  
✅ UIViewController 扩展  

### 技术亮点

⭐ 完整的路由架构设计  
⭐ 支持外部 URL 唤起  
⭐ 拦截器统一处理  
⭐ Routable 协议解耦  
⭐ 灵活的扩展性  

### 面试价值

🎯 展示架构设计能力  
🎯 理解解耦和模块化  
🎯 掌握协议编程  
🎯 了解组件化方案  
🎯 实践设计模式  

---

**路由框架是组件化架构的核心！🚀**

