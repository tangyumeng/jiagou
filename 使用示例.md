# 使用示例

本文档提供了在实际项目中使用多任务下载器的各种示例代码。

---

## 一、基础使用

### 1.1 添加单个下载任务

```swift
import UIKit

class MyViewController: UIViewController {
    
    let downloadManager = DownloadManager.shared
    
    func downloadFile() {
        // 创建下载URL
        guard let url = URL(string: "https://example.com/file.zip") else {
            return
        }
        
        // 添加任务（自定义文件名）
        let task = downloadManager.addTask(url: url, fileName: "myfile.zip")
        
        // 监听进度
        task.onProgressChanged = { [weak self] task in
            print("下载进度: \(Int(task.progress * 100))%")
            print("下载速度: \(task.formattedSpeed())")
            // 更新UI
            self?.updateProgressUI(task)
        }
        
        // 监听状态
        task.onStateChanged = { [weak self] task in
            print("状态变化: \(task.stateDescription())")
            // 更新UI
            self?.updateStateUI(task)
        }
        
        // 开始下载
        downloadManager.startDownload(taskId: task.id)
    }
    
    private func updateProgressUI(_ task: DownloadTask) {
        // 更新进度条
        // progressView.progress = Float(task.progress)
    }
    
    private func updateStateUI(_ task: DownloadTask) {
        // 更新状态标签
        // stateLabel.text = task.stateDescription()
    }
}
```

### 1.2 批量添加下载任务

```swift
func downloadMultipleFiles() {
    let urls = [
        "https://example.com/file1.pdf",
        "https://example.com/file2.zip",
        "https://example.com/file3.mp4"
    ]
    
    for urlString in urls {
        guard let url = URL(string: urlString) else { continue }
        let task = downloadManager.addTask(url: url)
        downloadManager.startDownload(taskId: task.id)
    }
    
    // 任务会根据并发限制自动排队
    print("添加了 \(urls.count) 个下载任务")
}
```

---

## 二、控制下载

### 2.1 暂停和继续

```swift
class DownloadControlExample {
    let downloadManager = DownloadManager.shared
    var currentTaskId: String?
    
    // 开始下载
    func startDownload(url: URL) {
        let task = downloadManager.addTask(url: url)
        currentTaskId = task.id
        downloadManager.startDownload(taskId: task.id)
    }
    
    // 暂停下载
    func pauseDownload() {
        guard let taskId = currentTaskId else { return }
        downloadManager.pauseDownload(taskId: taskId)
        print("已暂停下载")
    }
    
    // 继续下载
    func resumeDownload() {
        guard let taskId = currentTaskId else { return }
        downloadManager.startDownload(taskId: taskId)
        print("继续下载")
    }
    
    // 取消下载
    func cancelDownload() {
        guard let taskId = currentTaskId else { return }
        downloadManager.cancelDownload(taskId: taskId)
        print("已取消下载")
    }
    
    // 删除任务和文件
    func deleteTask() {
        guard let taskId = currentTaskId else { return }
        downloadManager.removeTask(taskId: taskId)
        print("已删除任务")
    }
}
```

### 2.2 智能控制：根据状态决定操作

```swift
func toggleDownload(task: DownloadTask) {
    switch task.state {
    case .waiting:
        print("任务正在等待，无需操作")
        
    case .downloading:
        // 正在下载，则暂停
        downloadManager.pauseDownload(taskId: task.id)
        
    case .paused:
        // 已暂停，则继续
        downloadManager.startDownload(taskId: task.id)
        
    case .completed:
        print("任务已完成")
        openFile(task)
        
    case .failed:
        // 失败后重试
        downloadManager.startDownload(taskId: task.id)
        
    case .cancelled:
        // 取消后重新开始
        downloadManager.startDownload(taskId: task.id)
    }
}

func openFile(_ task: DownloadTask) {
    guard let path = task.destinationPath else { return }
    // 打开文件的逻辑
    print("打开文件: \(path)")
}
```

---

## 三、代理模式使用

### 3.1 实现代理接收通知

```swift
class DownloadViewController: UIViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 设置代理
        DownloadManager.shared.delegate = self
    }
}

// MARK: - DownloadManagerDelegate
extension DownloadViewController: DownloadManagerDelegate {
    
    // 任务更新（进度变化）
    func downloadManager(_ manager: DownloadManager, didUpdateTask task: DownloadTask) {
        print("任务更新: \(task.fileName)")
        print("进度: \(task.progress)")
        print("速度: \(task.formattedSpeed())")
        
        // 更新UI
        updateTaskCell(task)
    }
    
    // 任务完成
    func downloadManager(_ manager: DownloadManager, didCompleteTask task: DownloadTask) {
        print("✅ 下载完成: \(task.fileName)")
        print("文件路径: \(task.destinationPath?.path ?? "")")
        
        // 显示通知
        showCompletionNotification(task)
        
        // 可以自动打开文件、分享文件等
        processCompletedFile(task)
    }
    
    // 任务失败
    func downloadManager(_ manager: DownloadManager, didFailTask task: DownloadTask, withError error: Error) {
        print("❌ 下载失败: \(task.fileName)")
        print("错误信息: \(error.localizedDescription)")
        
        // 显示错误提示
        showErrorAlert(task, error: error)
        
        // 可以实现自动重试逻辑
        retryIfNeeded(task)
    }
    
    // 辅助方法
    private func updateTaskCell(_ task: DownloadTask) {
        // 刷新对应的cell
    }
    
    private func showCompletionNotification(_ task: DownloadTask) {
        let alert = UIAlertController(
            title: "下载完成",
            message: task.fileName,
            preferredStyle: .alert
        )
        alert.addAction(UIAlertAction(title: "确定", style: .default))
        present(alert, animated: true)
    }
    
    private func showErrorAlert(_ task: DownloadTask, error: Error) {
        let alert = UIAlertController(
            title: "下载失败",
            message: "\(task.fileName)\n\(error.localizedDescription)",
            preferredStyle: .alert
        )
        alert.addAction(UIAlertAction(title: "重试", style: .default) { [weak self] _ in
            self?.downloadManager.startDownload(taskId: task.id)
        })
        alert.addAction(UIAlertAction(title: "取消", style: .cancel))
        present(alert, animated: true)
    }
    
    private func processCompletedFile(_ task: DownloadTask) {
        // 处理下载完成的文件
    }
    
    private func retryIfNeeded(_ task: DownloadTask) {
        // 实现自动重试逻辑
    }
}
```

---

## 四、高级用法

### 4.1 管理下载队列

```swift
class DownloadQueueManager {
    let downloadManager = DownloadManager.shared
    
    // 获取所有任务
    func getAllDownloads() -> [DownloadTask] {
        return downloadManager.getAllTasks()
    }
    
    // 获取正在下载的任务
    func getActiveDownloads() -> [DownloadTask] {
        return downloadManager.getAllTasks().filter { 
            $0.state == .downloading 
        }
    }
    
    // 获取等待中的任务
    func getWaitingDownloads() -> [DownloadTask] {
        return downloadManager.getAllTasks().filter { 
            $0.state == .waiting 
        }
    }
    
    // 获取已完成的任务
    func getCompletedDownloads() -> [DownloadTask] {
        return downloadManager.getAllTasks().filter { 
            $0.state == .completed 
        }
    }
    
    // 暂停所有下载
    func pauseAll() {
        let activeTasks = getActiveDownloads()
        activeTasks.forEach { task in
            downloadManager.pauseDownload(taskId: task.id)
        }
        print("已暂停 \(activeTasks.count) 个任务")
    }
    
    // 继续所有暂停的任务
    func resumeAll() {
        let pausedTasks = downloadManager.getAllTasks().filter { 
            $0.state == .paused 
        }
        pausedTasks.forEach { task in
            downloadManager.startDownload(taskId: task.id)
        }
        print("已继续 \(pausedTasks.count) 个任务")
    }
    
    // 清除所有已完成的任务
    func clearCompleted() {
        downloadManager.clearCompletedTasks()
        print("已清除所有已完成任务")
    }
    
    // 计算总下载进度
    func getTotalProgress() -> Double {
        let tasks = downloadManager.getAllTasks()
        guard !tasks.isEmpty else { return 0 }
        
        let totalProgress = tasks.reduce(0.0) { $0 + $1.progress }
        return totalProgress / Double(tasks.count)
    }
    
    // 获取下载统计信息
    func getStatistics() -> (total: Int, downloading: Int, completed: Int, failed: Int) {
        let tasks = downloadManager.getAllTasks()
        let downloading = tasks.filter { $0.state == .downloading }.count
        let completed = tasks.filter { $0.state == .completed }.count
        let failed = tasks.filter { $0.state == .failed }.count
        
        return (tasks.count, downloading, completed, failed)
    }
}
```

### 4.2 自动重试机制

```swift
class AutoRetryDownloadManager {
    let downloadManager = DownloadManager.shared
    let maxRetryCount = 3
    var retryCount: [String: Int] = [:]  // taskId: retryCount
    
    func startDownloadWithRetry(url: URL) {
        let task = downloadManager.addTask(url: url)
        retryCount[task.id] = 0
        
        // 监听失败
        task.onStateChanged = { [weak self] task in
            guard let self = self else { return }
            
            if task.state == .failed {
                self.handleFailure(task)
            }
        }
        
        downloadManager.startDownload(taskId: task.id)
    }
    
    private func handleFailure(_ task: DownloadTask) {
        let currentRetry = retryCount[task.id] ?? 0
        
        if currentRetry < maxRetryCount {
            // 延迟重试（指数退避）
            let delay = pow(2.0, Double(currentRetry))  // 1s, 2s, 4s
            
            DispatchQueue.main.asyncAfter(deadline: .now() + delay) { [weak self] in
                guard let self = self else { return }
                
                self.retryCount[task.id] = currentRetry + 1
                print("重试下载 (\(currentRetry + 1)/\(self.maxRetryCount)): \(task.fileName)")
                
                self.downloadManager.startDownload(taskId: task.id)
            }
        } else {
            print("❌ 重试次数已达上限: \(task.fileName)")
            retryCount.removeValue(forKey: task.id)
        }
    }
}
```

### 4.3 WiFi Only模式

```swift
import Network

class WiFiOnlyDownloadManager {
    let downloadManager = DownloadManager.shared
    let monitor = NWPathMonitor()
    var isWiFiConnected = false
    var pausedTasksByWiFi: Set<String> = []  // 因WiFi断开而暂停的任务
    
    init() {
        setupNetworkMonitoring()
    }
    
    private func setupNetworkMonitoring() {
        monitor.pathUpdateHandler = { [weak self] path in
            guard let self = self else { return }
            
            self.isWiFiConnected = path.usesInterfaceType(.wifi)
            
            if self.isWiFiConnected {
                self.resumeWiFiTasks()
            } else {
                self.pauseActiveTasksForWiFi()
            }
        }
        
        monitor.start(queue: DispatchQueue.global())
    }
    
    // 只在WiFi下下载
    func startDownloadWiFiOnly(url: URL) {
        let task = downloadManager.addTask(url: url)
        
        if isWiFiConnected {
            downloadManager.startDownload(taskId: task.id)
        } else {
            print("⚠️ 等待WiFi连接: \(task.fileName)")
            pausedTasksByWiFi.insert(task.id)
        }
    }
    
    private func pauseActiveTasksForWiFi() {
        let activeTasks = downloadManager.getAllTasks().filter { 
            $0.state == .downloading 
        }
        
        activeTasks.forEach { task in
            downloadManager.pauseDownload(taskId: task.id)
            pausedTasksByWiFi.insert(task.id)
        }
        
        print("⚠️ WiFi断开，已暂停 \(activeTasks.count) 个任务")
    }
    
    private func resumeWiFiTasks() {
        guard !pausedTasksByWiFi.isEmpty else { return }
        
        let tasksToResume = Array(pausedTasksByWiFi)
        pausedTasksByWiFi.removeAll()
        
        tasksToResume.forEach { taskId in
            downloadManager.startDownload(taskId: taskId)
        }
        
        print("✅ WiFi已连接，恢复 \(tasksToResume.count) 个任务")
    }
}
```

### 4.4 下载限速

```swift
extension DownloadManager {
    
    // 设置下载速度限制（字节/秒）
    func setSpeedLimit(_ bytesPerSecond: Int64) {
        // 注意：URLSession本身不直接支持限速
        // 这里提供一个思路，实际需要更复杂的实现
        
        // 方案1：使用自定义URLProtocol
        // 方案2：使用OperationQueue控制并发数
        // 方案3：分块下载，控制块的下载频率
        
        print("设置速度限制: \(ByteCountFormatter.string(fromByteCount: bytesPerSecond, countStyle: .file))/s")
    }
}
```

---

## 五、UI集成示例

### 5.1 简单的下载按钮

```swift
class SimpleDownloadView: UIView {
    
    let downloadButton = UIButton()
    let progressView = UIProgressView()
    let statusLabel = UILabel()
    
    var task: DownloadTask?
    let downloadManager = DownloadManager.shared
    
    func setupDownload(url: URL) {
        let task = downloadManager.addTask(url: url)
        self.task = task
        
        // 监听进度
        task.onProgressChanged = { [weak self] task in
            self?.progressView.progress = Float(task.progress)
            self?.statusLabel.text = "\(Int(task.progress * 100))% - \(task.formattedSpeed())"
        }
        
        // 监听状态
        task.onStateChanged = { [weak self] task in
            self?.updateButtonTitle(for: task.state)
        }
        
        // 按钮点击
        downloadButton.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside)
    }
    
    @objc private func buttonTapped() {
        guard let task = task else { return }
        
        switch task.state {
        case .waiting, .failed, .cancelled:
            downloadManager.startDownload(taskId: task.id)
            
        case .downloading:
            downloadManager.pauseDownload(taskId: task.id)
            
        case .paused:
            downloadManager.startDownload(taskId: task.id)
            
        case .completed:
            // 打开文件
            break
        }
    }
    
    private func updateButtonTitle(for state: DownloadState) {
        switch state {
        case .waiting:
            downloadButton.setTitle("等待中...", for: .normal)
        case .downloading:
            downloadButton.setTitle("暂停", for: .normal)
        case .paused:
            downloadButton.setTitle("继续", for: .normal)
        case .completed:
            downloadButton.setTitle("打开", for: .normal)
        case .failed:
            downloadButton.setTitle("重试", for: .normal)
        case .cancelled:
            downloadButton.setTitle("下载", for: .normal)
        }
    }
}
```

### 5.2 自定义进度视图

```swift
class CircularProgressView: UIView {
    
    var progress: Double = 0 {
        didSet {
            setNeedsDisplay()
        }
    }
    
    override func draw(_ rect: CGRect) {
        let center = CGPoint(x: bounds.midX, y: bounds.midY)
        let radius = min(bounds.width, bounds.height) / 2 - 10
        let startAngle = -CGFloat.pi / 2
        let endAngle = startAngle + 2 * CGFloat.pi * CGFloat(progress)
        
        // 背景圆
        let bgPath = UIBezierPath(
            arcCenter: center,
            radius: radius,
            startAngle: 0,
            endAngle: 2 * CGFloat.pi,
            clockwise: true
        )
        UIColor.systemGray5.setStroke()
        bgPath.lineWidth = 8
        bgPath.stroke()
        
        // 进度圆
        let progressPath = UIBezierPath(
            arcCenter: center,
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle,
            clockwise: true
        )
        UIColor.systemBlue.setStroke()
        progressPath.lineWidth = 8
        progressPath.stroke()
    }
    
    func bindToTask(_ task: DownloadTask) {
        task.onProgressChanged = { [weak self] task in
            self?.progress = task.progress
        }
    }
}
```

---

## 六、持久化示例（扩展）

### 6.1 保存任务到UserDefaults

```swift
extension DownloadTask {
    
    // 转换为字典
    func toDictionary() -> [String: Any] {
        return [
            "id": id,
            "url": url.absoluteString,
            "fileName": fileName,
            "totalBytes": totalBytes,
            "downloadedBytes": downloadedBytes
        ]
    }
    
    // 从字典创建
    static func fromDictionary(_ dict: [String: Any]) -> DownloadTask? {
        guard let id = dict["id"] as? String,
              let urlString = dict["url"] as? String,
              let url = URL(string: urlString),
              let fileName = dict["fileName"] as? String else {
            return nil
        }
        
        let task = DownloadTask(url: url, fileName: fileName)
        task.totalBytes = dict["totalBytes"] as? Int64 ?? 0
        task.downloadedBytes = dict["downloadedBytes"] as? Int64 ?? 0
        return task
    }
}

class PersistentDownloadManager {
    
    func saveTasks(_ tasks: [DownloadTask]) {
        let taskDicts = tasks.map { $0.toDictionary() }
        UserDefaults.standard.set(taskDicts, forKey: "downloadTasks")
    }
    
    func loadTasks() -> [DownloadTask] {
        guard let taskDicts = UserDefaults.standard.array(forKey: "downloadTasks") as? [[String: Any]] else {
            return []
        }
        
        return taskDicts.compactMap { DownloadTask.fromDictionary($0) }
    }
}
```

---

## 七、测试示例

### 7.1 单元测试

```swift
import XCTest

class DownloadManagerTests: XCTestCase {
    
    var downloadManager: DownloadManager!
    
    override func setUp() {
        super.setUp()
        downloadManager = DownloadManager.shared
    }
    
    func testAddTask() {
        let url = URL(string: "https://example.com/file.zip")!
        let task = downloadManager.addTask(url: url, fileName: "test.zip")
        
        XCTAssertNotNil(task)
        XCTAssertEqual(task.fileName, "test.zip")
        XCTAssertEqual(task.url, url)
        XCTAssertEqual(task.state, .waiting)
    }
    
    func testGetTask() {
        let url = URL(string: "https://example.com/file.zip")!
        let task = downloadManager.addTask(url: url)
        
        let retrievedTask = downloadManager.getTask(byId: task.id)
        
        XCTAssertNotNil(retrievedTask)
        XCTAssertEqual(retrievedTask?.id, task.id)
    }
    
    func testConcurrentLimit() {
        let urls = (1...5).map { URL(string: "https://example.com/file\($0).zip")! }
        let tasks = urls.map { downloadManager.addTask(url: $0) }
        
        tasks.forEach { task in
            downloadManager.startDownload(taskId: task.id)
        }
        
        // 等待一段时间让任务启动
        Thread.sleep(forTimeInterval: 1)
        
        let downloadingTasks = tasks.filter { $0.state == .downloading }
        XCTAssertLessThanOrEqual(downloadingTasks.count, 3)
    }
}
```

---

## 八、完整示例：图片批量下载器

```swift
class ImageBatchDownloader {
    let downloadManager = DownloadManager.shared
    var imageURLs: [URL] = []
    var completedCount = 0
    var onAllComplete: (() -> Void)?
    
    func downloadImages(urls: [URL], completion: @escaping () -> Void) {
        self.imageURLs = urls
        self.completedCount = 0
        self.onAllComplete = completion
        
        // 设置代理
        downloadManager.delegate = self
        
        // 开始下载
        urls.forEach { url in
            let task = downloadManager.addTask(url: url)
            downloadManager.startDownload(taskId: task.id)
        }
    }
}

extension ImageBatchDownloader: DownloadManagerDelegate {
    
    func downloadManager(_ manager: DownloadManager, didUpdateTask task: DownloadTask) {
        let progress = Double(completedCount) / Double(imageURLs.count)
        print("批量下载进度: \(Int(progress * 100))%")
    }
    
    func downloadManager(_ manager: DownloadManager, didCompleteTask task: DownloadTask) {
        completedCount += 1
        print("✅ 完成: \(completedCount)/\(imageURLs.count)")
        
        if completedCount == imageURLs.count {
            print("🎉 所有图片下载完成！")
            onAllComplete?()
        }
    }
    
    func downloadManager(_ manager: DownloadManager, didFailTask task: DownloadTask, withError error: Error) {
        print("❌ 失败: \(task.fileName)")
        // 可以实现重试或跳过
        completedCount += 1  // 算作已处理
    }
}

// 使用示例
let downloader = ImageBatchDownloader()
let imageURLs = [
    URL(string: "https://example.com/image1.jpg")!,
    URL(string: "https://example.com/image2.jpg")!,
    URL(string: "https://example.com/image3.jpg")!
]

downloader.downloadImages(urls: imageURLs) {
    print("全部完成，可以展示图片了")
}
```

---

## 总结

以上示例涵盖了：
- ✅ 基础下载操作
- ✅ 任务控制（暂停/继续/取消）
- ✅ 代理模式使用
- ✅ 队列管理
- ✅ 自动重试
- ✅ WiFi Only模式
- ✅ UI集成
- ✅ 持久化
- ✅ 单元测试
- ✅ 批量下载

这些示例可以直接用于实际项目中，根据需求进行调整和扩展。

