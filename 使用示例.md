# ä½¿ç”¨ç¤ºä¾‹

æœ¬æ–‡æ¡£æä¾›äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨å¤šä»»åŠ¡ä¸‹è½½å™¨çš„å„ç§ç¤ºä¾‹ä»£ç ã€‚

---

## ä¸€ã€åŸºç¡€ä½¿ç”¨

### 1.1 æ·»åŠ å•ä¸ªä¸‹è½½ä»»åŠ¡

```swift
import UIKit

class MyViewController: UIViewController {
    
    let downloadManager = DownloadManager.shared
    
    func downloadFile() {
        // åˆ›å»ºä¸‹è½½URL
        guard let url = URL(string: "https://example.com/file.zip") else {
            return
        }
        
        // æ·»åŠ ä»»åŠ¡ï¼ˆè‡ªå®šä¹‰æ–‡ä»¶åï¼‰
        let task = downloadManager.addTask(url: url, fileName: "myfile.zip")
        
        // ç›‘å¬è¿›åº¦
        task.onProgressChanged = { [weak self] task in
            print("ä¸‹è½½è¿›åº¦: \(Int(task.progress * 100))%")
            print("ä¸‹è½½é€Ÿåº¦: \(task.formattedSpeed())")
            // æ›´æ–°UI
            self?.updateProgressUI(task)
        }
        
        // ç›‘å¬çŠ¶æ€
        task.onStateChanged = { [weak self] task in
            print("çŠ¶æ€å˜åŒ–: \(task.stateDescription())")
            // æ›´æ–°UI
            self?.updateStateUI(task)
        }
        
        // å¼€å§‹ä¸‹è½½
        downloadManager.startDownload(taskId: task.id)
    }
    
    private func updateProgressUI(_ task: DownloadTask) {
        // æ›´æ–°è¿›åº¦æ¡
        // progressView.progress = Float(task.progress)
    }
    
    private func updateStateUI(_ task: DownloadTask) {
        // æ›´æ–°çŠ¶æ€æ ‡ç­¾
        // stateLabel.text = task.stateDescription()
    }
}
```

### 1.2 æ‰¹é‡æ·»åŠ ä¸‹è½½ä»»åŠ¡

```swift
func downloadMultipleFiles() {
    let urls = [
        "https://example.com/file1.pdf",
        "https://example.com/file2.zip",
        "https://example.com/file3.mp4"
    ]
    
    for urlString in urls {
        guard let url = URL(string: urlString) else { continue }
        let task = downloadManager.addTask(url: url)
        downloadManager.startDownload(taskId: task.id)
    }
    
    // ä»»åŠ¡ä¼šæ ¹æ®å¹¶å‘é™åˆ¶è‡ªåŠ¨æ’é˜Ÿ
    print("æ·»åŠ äº† \(urls.count) ä¸ªä¸‹è½½ä»»åŠ¡")
}
```

---

## äºŒã€æ§åˆ¶ä¸‹è½½

### 2.1 æš‚åœå’Œç»§ç»­

```swift
class DownloadControlExample {
    let downloadManager = DownloadManager.shared
    var currentTaskId: String?
    
    // å¼€å§‹ä¸‹è½½
    func startDownload(url: URL) {
        let task = downloadManager.addTask(url: url)
        currentTaskId = task.id
        downloadManager.startDownload(taskId: task.id)
    }
    
    // æš‚åœä¸‹è½½
    func pauseDownload() {
        guard let taskId = currentTaskId else { return }
        downloadManager.pauseDownload(taskId: taskId)
        print("å·²æš‚åœä¸‹è½½")
    }
    
    // ç»§ç»­ä¸‹è½½
    func resumeDownload() {
        guard let taskId = currentTaskId else { return }
        downloadManager.startDownload(taskId: taskId)
        print("ç»§ç»­ä¸‹è½½")
    }
    
    // å–æ¶ˆä¸‹è½½
    func cancelDownload() {
        guard let taskId = currentTaskId else { return }
        downloadManager.cancelDownload(taskId: taskId)
        print("å·²å–æ¶ˆä¸‹è½½")
    }
    
    // åˆ é™¤ä»»åŠ¡å’Œæ–‡ä»¶
    func deleteTask() {
        guard let taskId = currentTaskId else { return }
        downloadManager.removeTask(taskId: taskId)
        print("å·²åˆ é™¤ä»»åŠ¡")
    }
}
```

### 2.2 æ™ºèƒ½æ§åˆ¶ï¼šæ ¹æ®çŠ¶æ€å†³å®šæ“ä½œ

```swift
func toggleDownload(task: DownloadTask) {
    switch task.state {
    case .waiting:
        print("ä»»åŠ¡æ­£åœ¨ç­‰å¾…ï¼Œæ— éœ€æ“ä½œ")
        
    case .downloading:
        // æ­£åœ¨ä¸‹è½½ï¼Œåˆ™æš‚åœ
        downloadManager.pauseDownload(taskId: task.id)
        
    case .paused:
        // å·²æš‚åœï¼Œåˆ™ç»§ç»­
        downloadManager.startDownload(taskId: task.id)
        
    case .completed:
        print("ä»»åŠ¡å·²å®Œæˆ")
        openFile(task)
        
    case .failed:
        // å¤±è´¥åé‡è¯•
        downloadManager.startDownload(taskId: task.id)
        
    case .cancelled:
        // å–æ¶ˆåé‡æ–°å¼€å§‹
        downloadManager.startDownload(taskId: task.id)
    }
}

func openFile(_ task: DownloadTask) {
    guard let path = task.destinationPath else { return }
    // æ‰“å¼€æ–‡ä»¶çš„é€»è¾‘
    print("æ‰“å¼€æ–‡ä»¶: \(path)")
}
```

---

## ä¸‰ã€ä»£ç†æ¨¡å¼ä½¿ç”¨

### 3.1 å®ç°ä»£ç†æ¥æ”¶é€šçŸ¥

```swift
class DownloadViewController: UIViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // è®¾ç½®ä»£ç†
        DownloadManager.shared.delegate = self
    }
}

// MARK: - DownloadManagerDelegate
extension DownloadViewController: DownloadManagerDelegate {
    
    // ä»»åŠ¡æ›´æ–°ï¼ˆè¿›åº¦å˜åŒ–ï¼‰
    func downloadManager(_ manager: DownloadManager, didUpdateTask task: DownloadTask) {
        print("ä»»åŠ¡æ›´æ–°: \(task.fileName)")
        print("è¿›åº¦: \(task.progress)")
        print("é€Ÿåº¦: \(task.formattedSpeed())")
        
        // æ›´æ–°UI
        updateTaskCell(task)
    }
    
    // ä»»åŠ¡å®Œæˆ
    func downloadManager(_ manager: DownloadManager, didCompleteTask task: DownloadTask) {
        print("âœ… ä¸‹è½½å®Œæˆ: \(task.fileName)")
        print("æ–‡ä»¶è·¯å¾„: \(task.destinationPath?.path ?? "")")
        
        // æ˜¾ç¤ºé€šçŸ¥
        showCompletionNotification(task)
        
        // å¯ä»¥è‡ªåŠ¨æ‰“å¼€æ–‡ä»¶ã€åˆ†äº«æ–‡ä»¶ç­‰
        processCompletedFile(task)
    }
    
    // ä»»åŠ¡å¤±è´¥
    func downloadManager(_ manager: DownloadManager, didFailTask task: DownloadTask, withError error: Error) {
        print("âŒ ä¸‹è½½å¤±è´¥: \(task.fileName)")
        print("é”™è¯¯ä¿¡æ¯: \(error.localizedDescription)")
        
        // æ˜¾ç¤ºé”™è¯¯æç¤º
        showErrorAlert(task, error: error)
        
        // å¯ä»¥å®ç°è‡ªåŠ¨é‡è¯•é€»è¾‘
        retryIfNeeded(task)
    }
    
    // è¾…åŠ©æ–¹æ³•
    private func updateTaskCell(_ task: DownloadTask) {
        // åˆ·æ–°å¯¹åº”çš„cell
    }
    
    private func showCompletionNotification(_ task: DownloadTask) {
        let alert = UIAlertController(
            title: "ä¸‹è½½å®Œæˆ",
            message: task.fileName,
            preferredStyle: .alert
        )
        alert.addAction(UIAlertAction(title: "ç¡®å®š", style: .default))
        present(alert, animated: true)
    }
    
    private func showErrorAlert(_ task: DownloadTask, error: Error) {
        let alert = UIAlertController(
            title: "ä¸‹è½½å¤±è´¥",
            message: "\(task.fileName)\n\(error.localizedDescription)",
            preferredStyle: .alert
        )
        alert.addAction(UIAlertAction(title: "é‡è¯•", style: .default) { [weak self] _ in
            self?.downloadManager.startDownload(taskId: task.id)
        })
        alert.addAction(UIAlertAction(title: "å–æ¶ˆ", style: .cancel))
        present(alert, animated: true)
    }
    
    private func processCompletedFile(_ task: DownloadTask) {
        // å¤„ç†ä¸‹è½½å®Œæˆçš„æ–‡ä»¶
    }
    
    private func retryIfNeeded(_ task: DownloadTask) {
        // å®ç°è‡ªåŠ¨é‡è¯•é€»è¾‘
    }
}
```

---

## å››ã€é«˜çº§ç”¨æ³•

### 4.1 ç®¡ç†ä¸‹è½½é˜Ÿåˆ—

```swift
class DownloadQueueManager {
    let downloadManager = DownloadManager.shared
    
    // è·å–æ‰€æœ‰ä»»åŠ¡
    func getAllDownloads() -> [DownloadTask] {
        return downloadManager.getAllTasks()
    }
    
    // è·å–æ­£åœ¨ä¸‹è½½çš„ä»»åŠ¡
    func getActiveDownloads() -> [DownloadTask] {
        return downloadManager.getAllTasks().filter { 
            $0.state == .downloading 
        }
    }
    
    // è·å–ç­‰å¾…ä¸­çš„ä»»åŠ¡
    func getWaitingDownloads() -> [DownloadTask] {
        return downloadManager.getAllTasks().filter { 
            $0.state == .waiting 
        }
    }
    
    // è·å–å·²å®Œæˆçš„ä»»åŠ¡
    func getCompletedDownloads() -> [DownloadTask] {
        return downloadManager.getAllTasks().filter { 
            $0.state == .completed 
        }
    }
    
    // æš‚åœæ‰€æœ‰ä¸‹è½½
    func pauseAll() {
        let activeTasks = getActiveDownloads()
        activeTasks.forEach { task in
            downloadManager.pauseDownload(taskId: task.id)
        }
        print("å·²æš‚åœ \(activeTasks.count) ä¸ªä»»åŠ¡")
    }
    
    // ç»§ç»­æ‰€æœ‰æš‚åœçš„ä»»åŠ¡
    func resumeAll() {
        let pausedTasks = downloadManager.getAllTasks().filter { 
            $0.state == .paused 
        }
        pausedTasks.forEach { task in
            downloadManager.startDownload(taskId: task.id)
        }
        print("å·²ç»§ç»­ \(pausedTasks.count) ä¸ªä»»åŠ¡")
    }
    
    // æ¸…é™¤æ‰€æœ‰å·²å®Œæˆçš„ä»»åŠ¡
    func clearCompleted() {
        downloadManager.clearCompletedTasks()
        print("å·²æ¸…é™¤æ‰€æœ‰å·²å®Œæˆä»»åŠ¡")
    }
    
    // è®¡ç®—æ€»ä¸‹è½½è¿›åº¦
    func getTotalProgress() -> Double {
        let tasks = downloadManager.getAllTasks()
        guard !tasks.isEmpty else { return 0 }
        
        let totalProgress = tasks.reduce(0.0) { $0 + $1.progress }
        return totalProgress / Double(tasks.count)
    }
    
    // è·å–ä¸‹è½½ç»Ÿè®¡ä¿¡æ¯
    func getStatistics() -> (total: Int, downloading: Int, completed: Int, failed: Int) {
        let tasks = downloadManager.getAllTasks()
        let downloading = tasks.filter { $0.state == .downloading }.count
        let completed = tasks.filter { $0.state == .completed }.count
        let failed = tasks.filter { $0.state == .failed }.count
        
        return (tasks.count, downloading, completed, failed)
    }
}
```

### 4.2 è‡ªåŠ¨é‡è¯•æœºåˆ¶

```swift
class AutoRetryDownloadManager {
    let downloadManager = DownloadManager.shared
    let maxRetryCount = 3
    var retryCount: [String: Int] = [:]  // taskId: retryCount
    
    func startDownloadWithRetry(url: URL) {
        let task = downloadManager.addTask(url: url)
        retryCount[task.id] = 0
        
        // ç›‘å¬å¤±è´¥
        task.onStateChanged = { [weak self] task in
            guard let self = self else { return }
            
            if task.state == .failed {
                self.handleFailure(task)
            }
        }
        
        downloadManager.startDownload(taskId: task.id)
    }
    
    private func handleFailure(_ task: DownloadTask) {
        let currentRetry = retryCount[task.id] ?? 0
        
        if currentRetry < maxRetryCount {
            // å»¶è¿Ÿé‡è¯•ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
            let delay = pow(2.0, Double(currentRetry))  // 1s, 2s, 4s
            
            DispatchQueue.main.asyncAfter(deadline: .now() + delay) { [weak self] in
                guard let self = self else { return }
                
                self.retryCount[task.id] = currentRetry + 1
                print("é‡è¯•ä¸‹è½½ (\(currentRetry + 1)/\(self.maxRetryCount)): \(task.fileName)")
                
                self.downloadManager.startDownload(taskId: task.id)
            }
        } else {
            print("âŒ é‡è¯•æ¬¡æ•°å·²è¾¾ä¸Šé™: \(task.fileName)")
            retryCount.removeValue(forKey: task.id)
        }
    }
}
```

### 4.3 WiFi Onlyæ¨¡å¼

```swift
import Network

class WiFiOnlyDownloadManager {
    let downloadManager = DownloadManager.shared
    let monitor = NWPathMonitor()
    var isWiFiConnected = false
    var pausedTasksByWiFi: Set<String> = []  // å› WiFiæ–­å¼€è€Œæš‚åœçš„ä»»åŠ¡
    
    init() {
        setupNetworkMonitoring()
    }
    
    private func setupNetworkMonitoring() {
        monitor.pathUpdateHandler = { [weak self] path in
            guard let self = self else { return }
            
            self.isWiFiConnected = path.usesInterfaceType(.wifi)
            
            if self.isWiFiConnected {
                self.resumeWiFiTasks()
            } else {
                self.pauseActiveTasksForWiFi()
            }
        }
        
        monitor.start(queue: DispatchQueue.global())
    }
    
    // åªåœ¨WiFiä¸‹ä¸‹è½½
    func startDownloadWiFiOnly(url: URL) {
        let task = downloadManager.addTask(url: url)
        
        if isWiFiConnected {
            downloadManager.startDownload(taskId: task.id)
        } else {
            print("âš ï¸ ç­‰å¾…WiFiè¿æ¥: \(task.fileName)")
            pausedTasksByWiFi.insert(task.id)
        }
    }
    
    private func pauseActiveTasksForWiFi() {
        let activeTasks = downloadManager.getAllTasks().filter { 
            $0.state == .downloading 
        }
        
        activeTasks.forEach { task in
            downloadManager.pauseDownload(taskId: task.id)
            pausedTasksByWiFi.insert(task.id)
        }
        
        print("âš ï¸ WiFiæ–­å¼€ï¼Œå·²æš‚åœ \(activeTasks.count) ä¸ªä»»åŠ¡")
    }
    
    private func resumeWiFiTasks() {
        guard !pausedTasksByWiFi.isEmpty else { return }
        
        let tasksToResume = Array(pausedTasksByWiFi)
        pausedTasksByWiFi.removeAll()
        
        tasksToResume.forEach { taskId in
            downloadManager.startDownload(taskId: taskId)
        }
        
        print("âœ… WiFiå·²è¿æ¥ï¼Œæ¢å¤ \(tasksToResume.count) ä¸ªä»»åŠ¡")
    }
}
```

### 4.4 ä¸‹è½½é™é€Ÿ

```swift
extension DownloadManager {
    
    // è®¾ç½®ä¸‹è½½é€Ÿåº¦é™åˆ¶ï¼ˆå­—èŠ‚/ç§’ï¼‰
    func setSpeedLimit(_ bytesPerSecond: Int64) {
        // æ³¨æ„ï¼šURLSessionæœ¬èº«ä¸ç›´æ¥æ”¯æŒé™é€Ÿ
        // è¿™é‡Œæä¾›ä¸€ä¸ªæ€è·¯ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„å®ç°
        
        // æ–¹æ¡ˆ1ï¼šä½¿ç”¨è‡ªå®šä¹‰URLProtocol
        // æ–¹æ¡ˆ2ï¼šä½¿ç”¨OperationQueueæ§åˆ¶å¹¶å‘æ•°
        // æ–¹æ¡ˆ3ï¼šåˆ†å—ä¸‹è½½ï¼Œæ§åˆ¶å—çš„ä¸‹è½½é¢‘ç‡
        
        print("è®¾ç½®é€Ÿåº¦é™åˆ¶: \(ByteCountFormatter.string(fromByteCount: bytesPerSecond, countStyle: .file))/s")
    }
}
```

---

## äº”ã€UIé›†æˆç¤ºä¾‹

### 5.1 ç®€å•çš„ä¸‹è½½æŒ‰é’®

```swift
class SimpleDownloadView: UIView {
    
    let downloadButton = UIButton()
    let progressView = UIProgressView()
    let statusLabel = UILabel()
    
    var task: DownloadTask?
    let downloadManager = DownloadManager.shared
    
    func setupDownload(url: URL) {
        let task = downloadManager.addTask(url: url)
        self.task = task
        
        // ç›‘å¬è¿›åº¦
        task.onProgressChanged = { [weak self] task in
            self?.progressView.progress = Float(task.progress)
            self?.statusLabel.text = "\(Int(task.progress * 100))% - \(task.formattedSpeed())"
        }
        
        // ç›‘å¬çŠ¶æ€
        task.onStateChanged = { [weak self] task in
            self?.updateButtonTitle(for: task.state)
        }
        
        // æŒ‰é’®ç‚¹å‡»
        downloadButton.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside)
    }
    
    @objc private func buttonTapped() {
        guard let task = task else { return }
        
        switch task.state {
        case .waiting, .failed, .cancelled:
            downloadManager.startDownload(taskId: task.id)
            
        case .downloading:
            downloadManager.pauseDownload(taskId: task.id)
            
        case .paused:
            downloadManager.startDownload(taskId: task.id)
            
        case .completed:
            // æ‰“å¼€æ–‡ä»¶
            break
        }
    }
    
    private func updateButtonTitle(for state: DownloadState) {
        switch state {
        case .waiting:
            downloadButton.setTitle("ç­‰å¾…ä¸­...", for: .normal)
        case .downloading:
            downloadButton.setTitle("æš‚åœ", for: .normal)
        case .paused:
            downloadButton.setTitle("ç»§ç»­", for: .normal)
        case .completed:
            downloadButton.setTitle("æ‰“å¼€", for: .normal)
        case .failed:
            downloadButton.setTitle("é‡è¯•", for: .normal)
        case .cancelled:
            downloadButton.setTitle("ä¸‹è½½", for: .normal)
        }
    }
}
```

### 5.2 è‡ªå®šä¹‰è¿›åº¦è§†å›¾

```swift
class CircularProgressView: UIView {
    
    var progress: Double = 0 {
        didSet {
            setNeedsDisplay()
        }
    }
    
    override func draw(_ rect: CGRect) {
        let center = CGPoint(x: bounds.midX, y: bounds.midY)
        let radius = min(bounds.width, bounds.height) / 2 - 10
        let startAngle = -CGFloat.pi / 2
        let endAngle = startAngle + 2 * CGFloat.pi * CGFloat(progress)
        
        // èƒŒæ™¯åœ†
        let bgPath = UIBezierPath(
            arcCenter: center,
            radius: radius,
            startAngle: 0,
            endAngle: 2 * CGFloat.pi,
            clockwise: true
        )
        UIColor.systemGray5.setStroke()
        bgPath.lineWidth = 8
        bgPath.stroke()
        
        // è¿›åº¦åœ†
        let progressPath = UIBezierPath(
            arcCenter: center,
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle,
            clockwise: true
        )
        UIColor.systemBlue.setStroke()
        progressPath.lineWidth = 8
        progressPath.stroke()
    }
    
    func bindToTask(_ task: DownloadTask) {
        task.onProgressChanged = { [weak self] task in
            self?.progress = task.progress
        }
    }
}
```

---

## å…­ã€æŒä¹…åŒ–ç¤ºä¾‹ï¼ˆæ‰©å±•ï¼‰

### 6.1 ä¿å­˜ä»»åŠ¡åˆ°UserDefaults

```swift
extension DownloadTask {
    
    // è½¬æ¢ä¸ºå­—å…¸
    func toDictionary() -> [String: Any] {
        return [
            "id": id,
            "url": url.absoluteString,
            "fileName": fileName,
            "totalBytes": totalBytes,
            "downloadedBytes": downloadedBytes
        ]
    }
    
    // ä»å­—å…¸åˆ›å»º
    static func fromDictionary(_ dict: [String: Any]) -> DownloadTask? {
        guard let id = dict["id"] as? String,
              let urlString = dict["url"] as? String,
              let url = URL(string: urlString),
              let fileName = dict["fileName"] as? String else {
            return nil
        }
        
        let task = DownloadTask(url: url, fileName: fileName)
        task.totalBytes = dict["totalBytes"] as? Int64 ?? 0
        task.downloadedBytes = dict["downloadedBytes"] as? Int64 ?? 0
        return task
    }
}

class PersistentDownloadManager {
    
    func saveTasks(_ tasks: [DownloadTask]) {
        let taskDicts = tasks.map { $0.toDictionary() }
        UserDefaults.standard.set(taskDicts, forKey: "downloadTasks")
    }
    
    func loadTasks() -> [DownloadTask] {
        guard let taskDicts = UserDefaults.standard.array(forKey: "downloadTasks") as? [[String: Any]] else {
            return []
        }
        
        return taskDicts.compactMap { DownloadTask.fromDictionary($0) }
    }
}
```

---

## ä¸ƒã€æµ‹è¯•ç¤ºä¾‹

### 7.1 å•å…ƒæµ‹è¯•

```swift
import XCTest

class DownloadManagerTests: XCTestCase {
    
    var downloadManager: DownloadManager!
    
    override func setUp() {
        super.setUp()
        downloadManager = DownloadManager.shared
    }
    
    func testAddTask() {
        let url = URL(string: "https://example.com/file.zip")!
        let task = downloadManager.addTask(url: url, fileName: "test.zip")
        
        XCTAssertNotNil(task)
        XCTAssertEqual(task.fileName, "test.zip")
        XCTAssertEqual(task.url, url)
        XCTAssertEqual(task.state, .waiting)
    }
    
    func testGetTask() {
        let url = URL(string: "https://example.com/file.zip")!
        let task = downloadManager.addTask(url: url)
        
        let retrievedTask = downloadManager.getTask(byId: task.id)
        
        XCTAssertNotNil(retrievedTask)
        XCTAssertEqual(retrievedTask?.id, task.id)
    }
    
    func testConcurrentLimit() {
        let urls = (1...5).map { URL(string: "https://example.com/file\($0).zip")! }
        let tasks = urls.map { downloadManager.addTask(url: $0) }
        
        tasks.forEach { task in
            downloadManager.startDownload(taskId: task.id)
        }
        
        // ç­‰å¾…ä¸€æ®µæ—¶é—´è®©ä»»åŠ¡å¯åŠ¨
        Thread.sleep(forTimeInterval: 1)
        
        let downloadingTasks = tasks.filter { $0.state == .downloading }
        XCTAssertLessThanOrEqual(downloadingTasks.count, 3)
    }
}
```

---

## å…«ã€å®Œæ•´ç¤ºä¾‹ï¼šå›¾ç‰‡æ‰¹é‡ä¸‹è½½å™¨

```swift
class ImageBatchDownloader {
    let downloadManager = DownloadManager.shared
    var imageURLs: [URL] = []
    var completedCount = 0
    var onAllComplete: (() -> Void)?
    
    func downloadImages(urls: [URL], completion: @escaping () -> Void) {
        self.imageURLs = urls
        self.completedCount = 0
        self.onAllComplete = completion
        
        // è®¾ç½®ä»£ç†
        downloadManager.delegate = self
        
        // å¼€å§‹ä¸‹è½½
        urls.forEach { url in
            let task = downloadManager.addTask(url: url)
            downloadManager.startDownload(taskId: task.id)
        }
    }
}

extension ImageBatchDownloader: DownloadManagerDelegate {
    
    func downloadManager(_ manager: DownloadManager, didUpdateTask task: DownloadTask) {
        let progress = Double(completedCount) / Double(imageURLs.count)
        print("æ‰¹é‡ä¸‹è½½è¿›åº¦: \(Int(progress * 100))%")
    }
    
    func downloadManager(_ manager: DownloadManager, didCompleteTask task: DownloadTask) {
        completedCount += 1
        print("âœ… å®Œæˆ: \(completedCount)/\(imageURLs.count)")
        
        if completedCount == imageURLs.count {
            print("ğŸ‰ æ‰€æœ‰å›¾ç‰‡ä¸‹è½½å®Œæˆï¼")
            onAllComplete?()
        }
    }
    
    func downloadManager(_ manager: DownloadManager, didFailTask task: DownloadTask, withError error: Error) {
        print("âŒ å¤±è´¥: \(task.fileName)")
        // å¯ä»¥å®ç°é‡è¯•æˆ–è·³è¿‡
        completedCount += 1  // ç®—ä½œå·²å¤„ç†
    }
}

// ä½¿ç”¨ç¤ºä¾‹
let downloader = ImageBatchDownloader()
let imageURLs = [
    URL(string: "https://example.com/image1.jpg")!,
    URL(string: "https://example.com/image2.jpg")!,
    URL(string: "https://example.com/image3.jpg")!
]

downloader.downloadImages(urls: imageURLs) {
    print("å…¨éƒ¨å®Œæˆï¼Œå¯ä»¥å±•ç¤ºå›¾ç‰‡äº†")
}
```

---

## æ€»ç»“

ä»¥ä¸Šç¤ºä¾‹æ¶µç›–äº†ï¼š
- âœ… åŸºç¡€ä¸‹è½½æ“ä½œ
- âœ… ä»»åŠ¡æ§åˆ¶ï¼ˆæš‚åœ/ç»§ç»­/å–æ¶ˆï¼‰
- âœ… ä»£ç†æ¨¡å¼ä½¿ç”¨
- âœ… é˜Ÿåˆ—ç®¡ç†
- âœ… è‡ªåŠ¨é‡è¯•
- âœ… WiFi Onlyæ¨¡å¼
- âœ… UIé›†æˆ
- âœ… æŒä¹…åŒ–
- âœ… å•å…ƒæµ‹è¯•
- âœ… æ‰¹é‡ä¸‹è½½

è¿™äº›ç¤ºä¾‹å¯ä»¥ç›´æ¥ç”¨äºå®é™…é¡¹ç›®ä¸­ï¼Œæ ¹æ®éœ€æ±‚è¿›è¡Œè°ƒæ•´å’Œæ‰©å±•ã€‚

