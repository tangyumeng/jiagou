# 通知路由功能实现总结

## 📌 问题背景

**用户问题：** "路由存在一个问题，app未启动时，怎样从通知里面使用路由调起app"

这是一个非常实际的业务场景：
- 用户收到推送通知
- 用户点击通知
- App 从**完全未启动**状态启动
- 自动跳转到通知指定的页面

### 核心挑战

```
❌ 问题：
当 App 完全未启动时，点击通知后：
1. Window 和 RootViewController 还未创建
2. Router.open() 需要 currentViewController，但此时为 nil
3. 路由调用时机过早，UI 未就绪

✅ 解决方案：
延迟路由机制 - 先保存路由信息，等 UI 就绪后再执行
```

---

## 🎯 实现方案

### 架构设计

```
通知点击
  ↓
AppDelegate 接收
  ↓
UI 就绪？ ——→ 否 → setPendingRoute()（保存）
  ↓ 是                     ↓
  ↓                   等待 UI 就绪
  ↓                        ↓
  ↓              HomeViewController.viewDidAppear
  ↓                        ↓
  ↓              executePendingRoute()
  ↓                        ↓
  └───→ Router.open()（执行）
```

---

## 💻 代码改动详情

### 1. Router.swift（核心功能）

#### 新增属性

```swift
// 待处理的路由（用于 App 启动时 UI 未就绪的情况）
private var pendingURLString: String?
private var pendingParameters: [String: Any]?
```

#### 新增方法

**1️⃣ setPendingRoute() - 设置待处理路由**

```swift
func setPendingRoute(_ urlString: String, parameters: [String: Any] = [:]) {
    if pendingURLString != nil {
        print("⚠️ 覆盖之前的待处理路由：\(pendingURLString!)")
    }
    print("📌 设置待处理路由：\(urlString)")
    pendingURLString = urlString
    pendingParameters = parameters
}
```

**使用场景：** App 启动时，UI 还未就绪，先保存路由信息

---

**2️⃣ executePendingRoute() - 执行待处理路由**

```swift
@discardableResult
func executePendingRoute() -> Bool {
    guard let urlString = pendingURLString else {
        return false
    }
    
    print("🚀 执行待处理路由：\(urlString)")
    
    let parameters = pendingParameters ?? [:]
    
    // 清除待处理的路由
    pendingURLString = nil
    pendingParameters = nil
    
    // 延迟执行，确保 UI 完全就绪
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
        self?.open(urlString, parameters: parameters)
    }
    
    return true
}
```

**使用场景：** UI 就绪后（通常在 viewDidAppear 中）调用

**为什么延迟 0.5 秒？**
- 确保 navigationController 完全初始化
- 确保动画过渡完成
- 避免界面闪烁

---

**3️⃣ hasPendingRoute - 检查是否有待处理路由**

```swift
var hasPendingRoute: Bool {
    return pendingURLString != nil
}
```

**使用场景：** 在 viewDidAppear 中判断是否需要执行延迟路由

---

**4️⃣ clearPendingRoute() - 清除待处理路由**

```swift
func clearPendingRoute() {
    if pendingURLString != nil {
        print("🗑️ 清除待处理路由：\(pendingURLString!)")
    }
    pendingURLString = nil
    pendingParameters = nil
}
```

**使用场景：** 取消路由或重置状态

---

### 2. AppDelegate.swift（通知处理）

#### 导入框架

```swift
import UserNotifications
```

#### didFinishLaunching 改动

```swift
func application(...) -> Bool {
    // 1. 注册所有路由
    registerAllRoutes()
    
    // 2. 请求通知权限（新增）
    requestNotificationPermission()
    
    // 3. 处理从通知启动的情况（新增）
    handleLaunchFromNotification(launchOptions: launchOptions)
    
    return true
}
```

#### 新增方法

**1️⃣ requestNotificationPermission() - 请求通知权限**

```swift
private func requestNotificationPermission() {
    UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
        if granted {
            print("✅ 通知权限已授予")
            DispatchQueue.main.async {
                UIApplication.shared.registerForRemoteNotifications()
            }
        } else if let error = error {
            print("❌ 通知权限被拒绝：\(error.localizedDescription)")
        }
    }
    
    // 设置通知代理
    UNUserNotificationCenter.current().delegate = self
}
```

---

**2️⃣ handleLaunchFromNotification() - 处理从通知启动**

```swift
private func handleLaunchFromNotification(launchOptions: [UIApplication.LaunchOptionsKey: Any]?) {
    
    // 场景：从远程推送通知启动
    if let remoteNotification = launchOptions?[.remoteNotification] as? [AnyHashable: Any] {
        print("🔔 从远程通知启动 App")
        handleNotificationPayload(remoteNotification, isLaunch: true)
    }
}
```

**关键点：** `isLaunch: true` 表示 App 正在启动，UI 未就绪

---

**3️⃣ handleNotificationPayload() - 处理通知负载**

```swift
private func handleNotificationPayload(_ userInfo: [AnyHashable: Any], isLaunch: Bool) {
    print("📦 通知内容：\(userInfo)")
    
    // 从通知中提取路由信息
    guard let routeString = userInfo["route"] as? String else {
        print("⚠️ 通知中没有路由信息")
        return
    }
    
    print("🔗 提取到路由：\(routeString)")
    
    // 提取额外参数
    var parameters: [String: Any] = [:]
    if let params = userInfo["parameters"] as? [String: Any] {
        parameters = params
    }
    
    if isLaunch {
        // App 启动场景：设置待处理路由
        print("📌 App 正在启动，设置待处理路由")
        Router.shared.setPendingRoute(routeString, parameters: parameters)
    } else {
        // App 已运行场景：直接执行路由
        print("🚀 App 已运行，直接执行路由")
        Router.shared.open(routeString, parameters: parameters)
    }
}
```

**核心逻辑：**
- 启动场景 → `setPendingRoute()` 延迟执行
- 已运行场景 → `open()` 直接执行

---

**4️⃣ application(_:open:options:) - URL Scheme 处理**

```swift
func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
    print("🔗 通过 URL Scheme 打开：\(url)")
    
    // 检查 UI 是否就绪
    if Router.shared.currentViewController() != nil {
        // UI 已就绪，直接执行
        return Router.shared.open(url)
    } else {
        // UI 未就绪，设置待处理路由
        Router.shared.setPendingRoute(url.absoluteString)
        return true
    }
}
```

**使用场景：** 从其他 App 通过 URL Scheme 唤起

---

#### UNUserNotificationCenterDelegate 实现

```swift
extension AppDelegate: UNUserNotificationCenterDelegate {
    
    /// 前台收到通知
    func userNotificationCenter(_ center: UNUserNotificationCenter, 
                               willPresent notification: UNNotification, 
                               withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        print("🔔 前台收到通知：\(notification.request.content.userInfo)")
        
        // iOS 14+ 显示 banner
        if #available(iOS 14.0, *) {
            completionHandler([.banner, .sound, .badge])
        } else {
            completionHandler([.alert, .sound, .badge])
        }
    }
    
    /// 用户点击通知
    func userNotificationCenter(_ center: UNUserNotificationCenter, 
                               didReceive response: UNNotificationResponse, 
                               withCompletionHandler completionHandler: @escaping () -> Void) {
        print("🔔 用户点击了通知")
        
        let userInfo = response.notification.request.content.userInfo
        
        // 检查 App 是否刚启动（UI 未就绪）
        let isLaunch = Router.shared.currentViewController() == nil
        
        handleNotificationPayload(userInfo, isLaunch: isLaunch)
        
        completionHandler()
    }
}
```

**关键判断：**
```swift
let isLaunch = Router.shared.currentViewController() == nil
```
- `nil` = UI 未就绪 → 延迟路由
- `非nil` = UI 已就绪 → 直接执行

---

### 3. HomeViewController.swift（执行延迟路由）

#### viewDidAppear 改动

```swift
override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
    
    // 执行待处理的路由（如果有）
    // 使用场景：App 从通知或 URL Scheme 启动时，UI 未就绪，路由被延迟
    if Router.shared.hasPendingRoute {
        print("🚀 HomeViewController 已就绪，执行待处理路由")
        Router.shared.executePendingRoute()
    }
}
```

**为什么在 HomeViewController？**
- HomeViewController 是 RootViewController
- 第一个 viewDidAppear 时，UI 已完全就绪
- navigationController 已初始化

---

### 4. RouterDemoViewController.swift（测试功能）

#### 导入框架

```swift
import UserNotifications
```

#### 新增 UI 组件

```swift
private let section4Label = UILabel()
private let button7 = UIButton(type: .system)
```

#### 新增测试方法

```swift
@objc private func testNotification() {
    log("📤 准备发送本地通知...")
    
    // 创建通知内容
    let content = UNMutableNotificationContent()
    content.title = "路由测试通知"
    content.body = "点击此通知将跳转到 VIP 页面"
    content.sound = .default
    content.badge = 1
    
    // 添加路由信息到通知负载
    content.userInfo = [
        "route": "app://vip/999",
        "parameters": [
            "from": "notification",
            "message": "通知路由测试成功！"
        ]
    ]
    
    // 5秒后触发
    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)
    
    let request = UNNotificationRequest(
        identifier: UUID().uuidString,
        content: content,
        trigger: trigger
    )
    
    // 添加通知请求
    UNUserNotificationCenter.current().add(request) { [weak self] error in
        DispatchQueue.main.async {
            if let error = error {
                self?.log("❌ 通知发送失败：\(error.localizedDescription)")
            } else {
                self?.log("✅ 通知已调度（5秒后触发）")
                self?.log("💡 提示：")
                self?.log("  1. 前台：等待通知 banner 并点击")
                self?.log("  2. 后台：按 Home 键，等待并点击通知")
                self?.log("  3. 杀死 App：从多任务管理器杀死 App，等待并点击通知")
            }
        }
    }
}
```

---

## 📊 完整生命周期流程

### 场景 1：App 完全未启动 + 点击通知

```
用户点击通知
  ↓
系统启动 App
  ↓
1. AppDelegate.didFinishLaunching
   - registerAllRoutes()
   - requestNotificationPermission()
   - handleLaunchFromNotification(launchOptions)
     → 检测到通知启动
     → handleNotificationPayload(userInfo, isLaunch: true)
       → Router.setPendingRoute("app://vip/999") ✅
  ↓
2. SceneDelegate.willConnectTo
   - 创建 Window
   - 创建 RootViewController (HomeViewController)
   - window.makeKeyAndVisible()
  ↓
3. HomeViewController.viewDidLoad
  ↓
4. HomeViewController.viewWillAppear
  ↓
5. HomeViewController.viewDidAppear ✅
   - Router.hasPendingRoute → true
   - Router.executePendingRoute()
     → 延迟 0.5 秒
     → Router.open("app://vip/999")
       → 匹配路由 app://vip/:vipId
       → 创建 RouteVIPViewController
       → navigationController.push
  ↓
✅ 跳转到 VIP 页面
```

### 场景 2：App 在后台 + 点击通知

```
用户点击通知
  ↓
App 回到前台
  ↓
UNUserNotificationCenterDelegate.didReceive
  - currentViewController != nil（UI 已就绪）
  - handleNotificationPayload(userInfo, isLaunch: false)
    → Router.open("app://vip/999") 直接执行 ✅
  ↓
✅ 跳转到 VIP 页面
```

### 场景 3：App 在前台 + 收到通知

```
收到通知
  ↓
UNUserNotificationCenterDelegate.willPresent
  - 显示 banner
  ↓
用户点击 banner
  ↓
UNUserNotificationCenterDelegate.didReceive
  - currentViewController != nil（UI 已就绪）
  - Router.open("app://vip/999") 直接执行 ✅
  ↓
✅ 跳转到 VIP 页面
```

---

## 🎯 通知负载格式

### 标准格式

```json
{
  "aps": {
    "alert": {
      "title": "通知标题",
      "body": "通知内容"
    },
    "sound": "default",
    "badge": 1
  },
  "route": "app://vip/999",
  "parameters": {
    "from": "notification",
    "message": "自定义消息"
  }
}
```

### 字段说明

| 字段 | 必需 | 说明 |
|------|------|------|
| `aps` | ✅ | 系统通知配置 |
| `route` | ✅ | 路由 URL |
| `parameters` | ❌ | 额外参数（会合并到路由参数） |

### 实际案例

**1. 订单通知**
```json
{
  "aps": {"alert": "您有新订单"},
  "route": "app://order/12345"
}
```

**2. 商品推荐**
```json
{
  "aps": {"alert": "限时优惠"},
  "route": "app://product/8888",
  "parameters": {
    "name": "iPhone",
    "discount": "0.8"
  }
}
```

**3. 活动推广**
```json
{
  "aps": {"alert": "签到领红包"},
  "route": "app://activity/signin"
}
```

---

## ✅ 文件清单

修改的文件：

1. ✅ `jiagou/Router.swift` - 添加延迟路由功能
2. ✅ `jiagou/AppDelegate.swift` - 处理通知和权限
3. ✅ `jiagou/HomeViewController.swift` - 执行延迟路由
4. ✅ `jiagou/RouterDemoViewController.swift` - 添加测试功能

新增的文档：

1. ✅ `通知路由启动方案.md` - 详细设计文档
2. ✅ `通知路由快速测试指南.md` - 测试指南
3. ✅ `通知路由功能实现总结.md` - 本文档

---

## 🧪 测试步骤

### 快速测试

```
1. 运行 App
2. 主页 → 路由框架
3. 点击 [发送测试通知（5秒后）]
4. 从多任务管理器杀死 App
5. 等待通知出现
6. 点击通知
7. ✅ App 启动并跳转到 VIP 页面
```

### 验证清单

- [ ] 前台通知能正常跳转
- [ ] 后台通知能正常跳转
- [ ] 完全启动能正常跳转
- [ ] 控制台日志正确
- [ ] 参数正确传递

---

## 💡 技术亮点

### 1. 延迟路由机制

```swift
✅ 优点：
- 解决 UI 未就绪问题
- 统一处理启动和运行场景
- 用户体验流畅

❌ 如果没有延迟路由：
- currentViewController() 返回 nil
- 路由执行失败
- 用户看到首页，需要手动导航
```

### 2. 智能判断

```swift
let isLaunch = Router.shared.currentViewController() == nil
```

通过检查 currentViewController 判断 UI 是否就绪，自动选择执行策略。

### 3. 参数合并

```swift
路径参数 + Query参数 + 通知参数 → 自动合并
```

### 4. 完整的生命周期处理

- ✅ didFinishLaunching - 启动时处理
- ✅ didReceive - 前台/后台处理
- ✅ viewDidAppear - 执行延迟路由

---

## 🎉 总结

### 实现的功能

✅ **延迟路由机制** - 解决 UI 未就绪问题  
✅ **通知权限管理** - 自动请求和处理  
✅ **完整生命周期** - 支持所有启动场景  
✅ **URL Scheme** - 外部唤起支持  
✅ **测试工具** - 内置测试按钮  
✅ **详细日志** - 方便调试  

### 技术价值

🎯 **实际业务场景** - 解决真实问题  
🎯 **架构设计** - 延迟执行模式  
🎯 **生命周期管理** - 完整理解  
🎯 **面试价值** - 高频考点  

### 适用场景

📱 推送通知跳转  
📱 深度链接（Deep Linking）  
📱 Universal Links  
📱 URL Scheme 唤起  
📱 Widget 点击跳转  
📱 3D Touch 快捷操作  

---

**实现完成！立即运行项目测试通知路由功能！🚀**

