# 图片加载框架 - 类似 SDWebImage

## 📦 功能概述

实现了一个完整的图片加载框架，支持**三级缓存**（内存-磁盘-网络）、**自动下载**、**防止重复下载**等功能，类似于 SDWebImage。

---

## ✨ 核心特性

### 1. **三级缓存策略**
```
请求图片 → 内存缓存 → 磁盘缓存 → 网络下载
           ↓ 命中       ↓ 命中       ↓ 下载
         立即返回    异步返回    异步下载+缓存
```

### 2. **智能缓存管理**
- ✅ NSCache 自动管理内存（内存警告时自动清理）
- ✅ 磁盘缓存自动过期清理（默认 7 天）
- ✅ 磁盘缓存大小限制（默认 100MB）
- ✅ LRU 策略（最近最少使用）

### 3. **高性能下载**
- ✅ 防止重复下载（多个请求合并）
- ✅ 并发控制（最多 4 个并发下载）
- ✅ 自动重试（失败后重试 2 次）
- ✅ 下载超时控制（15 秒）

### 4. **UI 集成**
- ✅ UIImageView 扩展，一行代码加载图片
- ✅ 占位图支持
- ✅ 淡入动画
- ✅ Cell 复用安全（自动取消下载）

---

## 🏗️ 架构设计

### 类结构

```
┌────────────────────────────────────────┐
│         ImageCacheManager              │
│         缓存管理器（单例）              │
│  - 内存缓存（NSCache）                  │
│  - 磁盘缓存（FileManager）              │
│  - 缓存清理策略                         │
└────────────────────────────────────────┘
                  ↕
┌────────────────────────────────────────┐
│            ImageLoader                 │
│           图片加载器（单例）            │
│  - 网络下载（URLSession）               │
│  - 回调管理                             │
│  - 防重复下载                           │
└────────────────────────────────────────┘
                  ↕
┌────────────────────────────────────────┐
│       UIImageView+Extension            │
│           便捷扩展方法                  │
│  - setImage(with:placeholder:)         │
│  - 自动缓存+下载                        │
└────────────────────────────────────────┘
```

### 缓存策略流程图

```
                   ┌──────────────┐
                   │  请求图片    │
                   └──────┬───────┘
                          │
                   ┌──────▼───────┐
                   │  内存缓存?   │
                   └──┬────────┬──┘
                  是 │        │ 否
              ┌──────▼──┐     │
              │ 立即返回 │     │
              └──────────┘     │
                          ┌────▼────┐
                          │ 磁盘缓存?│
                          └──┬───┬──┘
                         是 │   │ 否
                    ┌───────▼┐  │
                    │异步返回 │  │
                    └────────┘   │
                           ┌─────▼──────┐
                           │  网络下载  │
                           └─────┬──────┘
                                 │
                        ┌────────▼────────┐
                        │ 保存到内存+磁盘 │
                        └────────┬────────┘
                                 │
                           ┌─────▼─────┐
                           │  返回图片  │
                           └───────────┘
```

---

## 💻 使用方法

### 1. 基本使用（UIImageView 扩展）

```swift
import UIKit

// 最简单的使用
imageView.setImage(with: url)

// 带占位图
imageView.setImage(with: url, placeholder: UIImage(named: "placeholder"))

// 带淡入动画
imageView.setImage(
    with: url,
    placeholder: UIImage(named: "placeholder"),
    transition: .fade(duration: 0.3)
)

// 带完成回调
imageView.setImage(with: url, placeholder: placeholder) { result in
    switch result {
    case .success(let image):
        print("✅ 图片加载成功：\(image.size)")
    case .failure(let error):
        print("❌ 图片加载失败：\(error)")
    }
}
```

### 2. TableView / CollectionView 中使用

```swift
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
    let cell = tableView.dequeueReusableCell(withIdentifier: "Cell", for: indexPath)
    let url = urls[indexPath.row]
    
    // 自动处理 cell 复用，不会出现图片错乱
    cell.imageView?.setImage(
        with: url,
        placeholder: UIImage(named: "placeholder"),
        transition: .fade(duration: 0.2)
    )
    
    return cell
}

// 在 prepareForReuse 中取消加载（可选，自动处理）
override func prepareForReuse() {
    super.prepareForReuse()
    imageView?.cancelImageLoad()
}
```

### 3. 直接使用 ImageLoader

```swift
let loader = ImageLoader.shared

// 加载图片
loader.loadImage(from: url) { result in
    switch result {
    case .success(let image):
        self.imageView.image = image
    case .failure(let error):
        print("加载失败：\(error)")
    }
}

// 强制刷新（忽略缓存）
var options = ImageLoadOptions()
options.forceRefresh = true
loader.loadImage(from: url, options: options) { result in
    // ...
}

// 取消下载
loader.cancelDownload(for: url)

// 预加载图片
let urls = [url1, url2, url3]
loader.prefetchImages(urls: urls)
```

### 4. 缓存管理

```swift
let loader = ImageLoader.shared

// 清空内存缓存
loader.clearMemoryCache()

// 清空磁盘缓存
loader.clearDiskCache {
    print("磁盘缓存已清空")
}

// 清空所有缓存
loader.clearAllCache {
    print("所有缓存已清空")
}

// 获取缓存大小
loader.getCacheSize { sizeString in
    print("缓存大小：\(sizeString)")  // 例如："25.3 MB"
}
```

### 5. 直接使用 ImageCacheManager

```swift
let cacheManager = ImageCacheManager.shared

// 手动缓存图片
cacheManager.cacheImage(image, for: url)

// 从缓存获取图片
cacheManager.cachedImage(for: url) { image in
    if let image = image {
        print("从缓存获取成功")
    }
}

// 清理过期缓存
cacheManager.cleanExpiredDiskCache()

// 获取缓存统计
cacheManager.getDiskCacheSize { size in
    print("磁盘缓存大小：\(size) 字节")
}

cacheManager.getDiskCacheCount { count in
    print("磁盘缓存文件数：\(count)")
}
```

---

## 🎯 核心技术实现

### 1. 内存缓存 - NSCache

```swift
private let memoryCache = NSCache<NSString, UIImage>()

// 配置
memoryCache.countLimit = 100              // 最多缓存 100 张
memoryCache.totalCostLimit = 50 * 1024 * 1024  // 最大 50MB

// 保存
let cost = image.imageCost  // 图片内存占用
memoryCache.setObject(image, forKey: key, cost: cost)

// 读取
let image = memoryCache.object(forKey: key)

// NSCache 优势：
// ✅ 自动管理内存，内存警告时自动清理
// ✅ 线程安全
// ✅ 支持 cost 限制（按内存大小限制）
```

**为什么选择 NSCache 而不是 Dictionary？**
- ✅ 自动内存管理
- ✅ 线程安全
- ✅ 内存警告时自动清理
- ✅ 支持 cost 和 count 双重限制

### 2. 磁盘缓存 - FileManager

```swift
// 缓存目录
let cacheDirectory = .cachesDirectory/ImageCache

// 缓存键（URL 的 MD5）
let cacheKey = url.absoluteString.md5
let cachePath = cacheDirectory/cacheKey

// 保存（异步）
ioQueue.async {
    let data = image.jpegData(compressionQuality: 0.8)
    try? data.write(to: cachePath)
}

// 读取（异步）
ioQueue.async {
    let data = try? Data(contentsOf: cachePath)
    let image = UIImage(data: data)
    DispatchQueue.main.async { completion(image) }
}

// 清理策略：
// 1. 时间过期：超过 7 天自动删除
// 2. 大小超限：删除最旧的文件
```

**为什么使用 MD5 作为缓存键？**
- ✅ URL 可能很长，MD5 固定长度
- ✅ URL 可能包含特殊字符，MD5 安全
- ✅ 唯一性保证

### 3. 防止重复下载

```swift
// 问题：多个 ImageView 请求同一张图片
// 解决：合并请求，只下载一次

// 回调字典
private var downloadCallbacks: [URL: [(Result<UIImage, Error>) -> Void]] = [:]

// 添加回调
if downloadTasks[url] != nil {
    // 已经在下载，添加到回调列表
    downloadCallbacks[url]?.append(completion)
    return
}

// 下载完成后通知所有回调
let callbacks = downloadCallbacks[url]
callbacks?.forEach { $0(.success(image)) }
```

### 4. Cell 复用安全

```swift
// 问题：TableView 快速滚动时，图片错乱
// 原因：cell 复用，异步下载完成时 cell 可能已经显示其他内容

// 解决方案：保存当前 URL
private var imageURL: URL?  // 关联对象

func setImage(with url: URL?) {
    // 保存当前 URL
    self.imageURL = url
    
    ImageLoader.shared.loadImage(from: url) { [weak self] result in
        guard let self = self else { return }
        
        // 检查 URL 是否匹配
        guard self.imageURL == url else { return }
        
        // 设置图片
        self.image = image
    }
}
```

### 5. 自动重试机制

```swift
private func downloadImage(
    from url: URL,
    retryCount: Int,  // 剩余重试次数
    completion: @escaping (Result<UIImage, Error>) -> Void
) {
    urlSession.dataTask(with: url) { data, response, error in
        if let error = error {
            // 还有重试次数，继续重试
            if retryCount > 0 {
                self.downloadImage(from: url, retryCount: retryCount - 1, completion: completion)
            } else {
                completion(.failure(error))
            }
        }
    }
}
```

---

## 📊 性能优化

### 1. 异步操作

```swift
// 所有磁盘 I/O 都在后台队列
private let ioQueue = DispatchQueue(label: "...", qos: .background)

ioQueue.async {
    // 读写磁盘
    DispatchQueue.main.async {
        // 回调主线程
    }
}
```

### 2. 并发控制

```swift
// 最多 4 个并发下载
private let downloadQueue = OperationQueue()
downloadQueue.maxConcurrentOperationCount = 4
```

### 3. 图片解码优化

```swift
// JPEG 压缩质量 0.8（平衡质量和大小）
let data = image.jpegData(compressionQuality: 0.8)

// 可扩展：支持 WebP、HEIC 等格式
```

### 4. 内存计算

```swift
// 准确计算图片内存占用
var imageCost: Int {
    guard let cgImage = cgImage else { return 0 }
    return cgImage.bytesPerRow * cgImage.height
}
```

---

## 🎤 面试要点

### 1. 为什么需要三级缓存？

```
内存缓存：
✅ 最快（纳秒级）
✅ 容量小（50MB）
✅ App 退出后清空
适合：最近使用的图片

磁盘缓存：
✅ 较快（毫秒级）
✅ 容量大（100MB）
✅ 持久化存储
适合：所有下载过的图片

网络下载：
❌ 最慢（秒级）
❌ 消耗流量
❌ 需要网络
兜底方案：缓存没有时才下载
```

### 2. 如何防止重复下载？

```swift
// 维护下载任务字典
private var downloadTasks: [URL: URLSessionDataTask] = [:]

// 维护回调列表
private var downloadCallbacks: [URL: [Callback]] = [:]

// 逻辑：
1. 检查 URL 是否已经在下载
2. 如果是，将回调添加到列表
3. 如果否，创建新的下载任务
4. 下载完成后，通知所有回调
```

### 3. 如何保证线程安全？

```swift
// NSCache 本身线程安全
// 字典需要加锁保护
private let lock = NSLock()

lock.lock()
// 访问字典
lock.unlock()

// 或使用 defer
lock.lock()
defer { lock.unlock() }
// 访问字典
```

### 4. 如何处理内存警告？

```swift
// 监听内存警告通知
NotificationCenter.default.addObserver(
    self,
    selector: #selector(handleMemoryWarning),
    name: UIApplication.didReceiveMemoryWarningNotification,
    object: nil
)

@objc private func handleMemoryWarning() {
    // 清空内存缓存
    memoryCache.removeAllObjects()
    
    // 磁盘缓存不清理（持久化）
}
```

### 5. 如何实现 LRU 策略？

```swift
// NSCache 内置 LRU 策略
// 当达到 countLimit 或 totalCostLimit 时，自动移除最久未使用的对象

// 磁盘缓存自己实现 LRU：
1. 记录文件修改时间
2. 超过大小限制时，按时间排序
3. 删除最旧的文件

fileInfos.sort { $0.modificationDate < $1.modificationDate }
```

### 6. SDWebImage vs 自己实现？

```
SDWebImage 优势：
✅ 功能完善（动图、渐进式加载等）
✅ 经过大量项目验证
✅ 持续维护更新

自己实现优势：
✅ 轻量级，可控性强
✅ 学习架构设计
✅ 定制化需求
✅ 面试加分

实际项目建议：使用成熟框架
学习项目建议：自己实现
```

---

## 🚀 扩展方向

### 短期扩展

1. **动图支持（GIF/APNG）**
   ```swift
   // 使用 ImageIO 解析动图
   // 播放动图帧序列
   ```

2. **渐进式加载**
   ```swift
   // 先显示模糊图
   // 逐步清晰化
   ```

3. **下载进度**
   ```swift
   // URLSessionDownloadDelegate
   // 显示下载百分比
   ```

### 中期扩展

4. **WebP 支持**
   ```swift
   // 集成 libwebp
   // WebP 格式更小
   ```

5. **图片处理**
   ```swift
   // 圆角、滤镜、裁剪
   // 缓存处理后的图片
   ```

6. **预加载策略**
   ```swift
   // 智能预测即将显示的图片
   // 提前下载
   ```

### 长期扩展

7. **CDN 优化**
   ```swift
   // 自动选择最快的 CDN 节点
   // 失败自动切换备用节点
   ```

8. **云端缓存同步**
   ```swift
   // iCloud 同步缓存
   // 多设备共享
   ```

---

## 🔍 对比分析

### vs SDWebImage

| 特性 | 本框架 | SDWebImage |
|------|--------|------------|
| 三级缓存 | ✅ | ✅ |
| 防重复下载 | ✅ | ✅ |
| 动图支持 | ❌ | ✅ |
| WebP 支持 | ❌ | ✅ |
| 渐进式加载 | ❌ | ✅ |
| 代码量 | ~500 行 | ~10000 行 |
| 学习成本 | 低 | 中 |

### vs Kingfisher (Swift)

| 特性 | 本框架 | Kingfisher |
|------|--------|------------|
| 语言 | Swift | Swift |
| 函数式编程 | 部分 | ✅ |
| Combine 支持 | ❌ | ✅ |
| SwiftUI 支持 | ❌ | ✅ |
| 处理器链 | ❌ | ✅ |

---

## 💡 总结

### 实现的功能

✅ 三级缓存（内存-磁盘-网络）  
✅ NSCache 自动内存管理  
✅ 磁盘缓存过期清理  
✅ 防止重复下载  
✅ 并发控制  
✅ 自动重试  
✅ Cell 复用安全  
✅ UIImageView 便捷扩展  
✅ 淡入动画  

### 技术亮点

⭐ 完整的三级缓存架构  
⭐ 高性能异步操作  
⭐ 线程安全设计  
⭐ 智能缓存管理策略  
⭐ 防止 cell 复用图片错乱  
⭐ 内存管理优化  

### 面试价值

🎯 展示架构设计能力  
🎯 理解缓存策略  
🎯 掌握多线程编程  
🎯 了解性能优化  
🎯 实践设计模式  

---

**图片加载框架是 iOS 面试的高频题！🔥**

