# 下载管理器 - 持久化功能详解

## 📦 功能概述

为下载管理器添加了完整的持久化功能，实现 **App 重启后自动恢复下载任务**，提升用户体验。

---

## ✨ 核心特性

### 1. **自动保存**
- ✅ 添加任务时自动保存
- ✅ 暂停任务时保存（包括 resumeData）
- ✅ 任务完成/失败时更新状态
- ✅ 删除任务时从持久化移除

### 2. **智能恢复**
- ✅ App 启动时自动恢复未完成的任务
- ✅ 恢复任务状态和进度
- ✅ 恢复断点续传数据
- ✅ 正在下载的任务自动改为等待状态

### 3. **数据管理**
- ✅ 使用 UserDefaults 存储（轻量、快速）
- ✅ 支持文件存储（大数据量时使用）
- ✅ 最多保存 100 个任务
- ✅ 自动清理已完成任务

---

## 🏗️ 架构设计

### 核心类

```
┌─────────────────────────────────────┐
│   DownloadTaskPersistence.swift     │
│   持久化管理器（单例）               │
│   - 保存/加载任务                    │
│   - UserDefaults / 文件存储          │
└─────────────────────────────────────┘
              ↕
┌─────────────────────────────────────┐
│    DownloadManager.swift             │
│    - 集成持久化调用                  │
│    - App 启动时恢复任务              │
└─────────────────────────────────────┘
              ↕
┌─────────────────────────────────────┐
│     DownloadTask.swift               │
│     - 支持序列化/反序列化            │
│     - convenience init(from:)        │
└─────────────────────────────────────┘
```

### 数据模型

```swift
// 可序列化的状态枚举
enum SerializableDownloadState: String, Codable {
    case waiting, downloading, paused
    case completed, failed, cancelled
}

// 可序列化的任务数据
struct DownloadTaskData: Codable {
    let id: String
    let url: String
    let fileName: String
    var state: SerializableDownloadState
    var progress: Double
    var totalBytes: Int64
    var downloadedBytes: Int64
    var destinationPath: String?
    var resumeData: Data?  // 断点续传数据
    var errorDescription: String?
    let createdAt: TimeInterval
}
```

---

## 💻 使用方法

### 1. 自动持久化（无需手动调用）

持久化功能已经集成到 `DownloadManager` 中，所有操作自动保存：

```swift
let manager = DownloadManager.shared

// 添加任务 → 自动保存
let task = manager.addTask(url: url, fileName: "file.zip")

// 暂停任务 → 自动保存（包括 resumeData）
manager.pauseDownload(taskId: task.id)

// 删除任务 → 自动从持久化移除
manager.removeTask(taskId: task.id)
```

### 2. 手动保存单个任务

```swift
// 方式1：通过 task 扩展
task.save()

// 方式2：通过持久化管理器
DownloadTaskPersistence.shared.saveTask(task)
```

### 3. App 启动时自动恢复

```swift
// DownloadManager 初始化时自动调用
private func restoreTasksFromPersistence() {
    let taskDataArray = DownloadTaskPersistence.shared.loadTasks()
    
    for taskData in taskDataArray {
        let task = DownloadTask(from: taskData)
        tasks[task.id] = task
        
        // 正在下载的任务改为等待状态
        if task.state == .downloading {
            task.state = .waiting
        }
    }
}
```

### 4. 手动管理持久化

```swift
// 清空所有持久化任务
DownloadTaskPersistence.shared.clearAllTasks()

// 清理已完成的任务
DownloadTaskPersistence.shared.clearCompletedTasks()

// 删除指定任务
DownloadTaskPersistence.shared.removeTask(withId: taskId)

// 加载所有任务
let taskDataArray = DownloadTaskPersistence.shared.loadTasks()
```

---

## 🎯 技术实现

### 1. Codable 序列化

```swift
// 编码（保存）
let encoder = JSONEncoder()
let data = try encoder.encode(taskDataArray)
userDefaults.set(data, forKey: tasksKey)

// 解码（加载）
let decoder = JSONDecoder()
let taskDataArray = try decoder.decode([DownloadTaskData].self, from: data)
```

### 2. 断点续传数据保存

```swift
// resumeData 是 Data 类型，自动支持 Codable
struct DownloadTaskData: Codable {
    var resumeData: Data?  // 暂停时保存，恢复时使用
}

// 暂停时保存
task.downloadTask?.cancel(byProducingResumeData: { resumeData in
    task.resumeData = resumeData
    task.state = .paused
    // 自动持久化
})

// 恢复时使用
if let resumeData = task.resumeData {
    let downloadTask = session.downloadTask(withResumeData: resumeData)
    downloadTask.resume()
}
```

### 3. 任务状态过滤

```swift
// 只保存有意义的任务（未完成的）
let tasksToSave = tasks.filter { task in
    task.state == .waiting || 
    task.state == .downloading || 
    task.state == .paused
}
```

### 4. 文件存储（高级功能）

当任务数量较多时，可使用文件存储：

```swift
// 保存到文件
DownloadTaskPersistence.shared.saveTasksToFile(tasks)

// 从文件加载
let taskDataArray = DownloadTaskPersistence.shared.loadTasksFromFile()
```

存储位置：`Documents/DownloadTasks/tasks.json`

---

## 📊 持久化策略

### 保存时机

| 操作 | 是否保存 | 保存内容 |
|------|---------|---------|
| 添加任务 | ✅ | 任务基本信息 |
| 开始下载 | ❌ | 状态由系统管理 |
| 暂停下载 | ✅ | 状态 + resumeData |
| 继续下载 | ❌ | 使用已保存的 resumeData |
| 任务完成 | ✅ | 更新状态为已完成 |
| 任务失败 | ✅ | 更新状态为失败 |
| 删除任务 | ✅ | 从持久化移除 |
| 清除已完成 | ✅ | 批量移除 |

### 不保存的内容

❌ 已完成的任务（除非手动指定）  
❌ 已取消的任务  
❌ 失败的任务（可选，目前保存）  
❌ 超过 100 个的任务（只保留前 100 个）  

---

## 🔍 调试和日志

所有持久化操作都会打印日志：

```
🔄 开始恢复 3 个任务...
✅ 恢复任务：file1.zip - 已暂停
✅ 恢复任务：file2.pdf - 等待中
✅ 恢复任务：file3.mp4 - 已暂停
📋 任务恢复完成

✅ 持久化：已保存 3 个任务
❌ 持久化失败：无法编码数据
```

---

## 🎤 面试要点

### 1. 为什么选择 UserDefaults？

```
优点：
✅ 简单易用，无需配置
✅ 轻量数据存储，读写快速
✅ 适合存储少量结构化数据（<1MB）
✅ 自动持久化到磁盘

缺点：
❌ 不适合大量数据
❌ 不支持复杂查询
❌ 线程安全性需要注意

适用场景：
- 下载任务列表（<100个）
- 用户设置和配置
- 简单的状态保存
```

### 2. 为什么不用 CoreData？

```
CoreData 适合：
- 复杂的关系型数据
- 大量数据（数千条以上）
- 需要复杂查询和排序
- 数据迁移需求

本项目：
- 数据量小（<100个任务）
- 数据结构简单
- UserDefaults 足够且更简单
```

### 3. 如何保证线程安全？

```swift
// UserDefaults 本身是线程安全的
// 但配合 DownloadManager 的队列使用更安全

taskQueue.async(flags: .barrier) {
    // 修改任务后保存
    self.tasks[task.id] = task
    DispatchQueue.main.async {
        self.saveTasksToPersistence()
    }
}
```

### 4. 断点续传数据如何持久化？

```swift
// resumeData 是 Data 类型，支持 Codable
struct DownloadTaskData: Codable {
    var resumeData: Data?  // 自动序列化/反序列化
}

// 暂停时：
task.downloadTask?.cancel(byProducingResumeData: { resumeData in
    task.resumeData = resumeData  // 保存
    // 持久化到 UserDefaults
})

// 恢复时：
if let resumeData = task.resumeData {
    let downloadTask = session.downloadTask(withResumeData: resumeData)
}
```

### 5. 如何优化大数据量？

```swift
// 方案1：限制保存数量
let limitedTasks = Array(taskDataArray.prefix(100))

// 方案2：使用文件存储
saveTasksToFile(tasks)  // JSON 文件

// 方案3：只保存关键信息
// 不保存已完成、已取消的任务

// 方案4：使用 CoreData 或 Realm
// 支持更大数据量和复杂查询
```

---

## 🚀 扩展方向

### 短期优化

1. **增量保存**
   - 只保存变化的任务，而非每次全量保存
   - 减少 I/O 操作

2. **异步保存**
   - 使用后台队列进行持久化
   - 不阻塞主线程

3. **数据压缩**
   - 对 resumeData 进行压缩
   - 减少存储空间

### 中期优化

4. **迁移到 CoreData**
   - 支持更大数据量
   - 支持复杂查询和排序
   - 自动数据迁移

5. **云同步**
   - iCloud 同步下载任务
   - 多设备共享下载列表

6. **数据加密**
   - 敏感数据加密存储
   - Keychain 存储关键信息

---

## 📝 测试建议

### 功能测试

```swift
// 1. 测试保存和加载
let task = DownloadTask(url: url, fileName: "test.zip")
task.save()
let loaded = DownloadTaskPersistence.shared.loadTasks()
// 验证：loaded 包含 task

// 2. 测试断点续传数据
// 暂停任务 → 杀掉 App → 重启
// 验证：resumeData 正确恢复

// 3. 测试状态转换
// 下载中的任务，重启后应该变为等待状态

// 4. 测试数据清理
// 清除已完成任务，验证持久化数据正确
```

### 性能测试

```swift
// 1. 大量任务保存
for i in 0..<200 {
    addTask(...)
}
// 验证：只保存前 100 个

// 2. 频繁保存
// 快速添加/删除任务
// 验证：不会造成卡顿
```

---

## 💡 总结

### 实现的功能

✅ 基于 UserDefaults 的轻量级持久化  
✅ 自动保存和恢复下载任务  
✅ 支持断点续传数据持久化  
✅ 智能状态管理和恢复  
✅ 完善的错误处理和日志  
✅ 支持文件存储（大数据量）  

### 技术亮点

⭐ Codable 协议优雅实现序列化  
⭐ 单例模式统一管理持久化  
⭐ 自动化保存，无需手动调用  
⭐ 与 DownloadManager 无缝集成  
⭐ 扩展性强，易于升级到 CoreData  

### 面试价值

🎯 展示数据持久化能力  
🎯 理解序列化/反序列化原理  
🎯 掌握 UserDefaults 使用  
🎯 了解 CoreData 的选型考虑  
🎯 实践了架构设计能力  

---

**持久化功能让下载管理器更加完整和实用！🎉**

