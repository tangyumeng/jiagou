# 模块中添加网络请求方案

## 📌 核心理念

在 **Protocol-Based Router** 方案中，模块是一个**完整的业务单元**，包含：
- ✅ 页面（UI）
- ✅ 业务逻辑
- ✅ 网络请求
- ✅ 数据存储
- ✅ 对外服务

---

## 💻 实现方式

### 方式 1：在模块内部直接实现网络请求（简单项目）

```swift
// ProductModule.swift

class ProductModule: ProductModuleProtocol {
    static let moduleName = "ProductModule"
    
    required init() {}
    
    // MARK: - 服务方法（包含网络请求）
    
    /// 获取商品信息（网络请求）
    func getProduct(productId: String, completion: @escaping (Product?) -> Void) {
        print("🌐 网络请求：获取商品 \(productId)")
        
        // 构建 URL
        guard let url = URL(string: "https://api.example.com/products/\(productId)") else {
            completion(nil)
            return
        }
        
        // 发起网络请求
        URLSession.shared.dataTask(with: url) { data, response, error in
            if let error = error {
                print("❌ 网络错误：\(error.localizedDescription)")
                DispatchQueue.main.async {
                    completion(nil)
                }
                return
            }
            
            guard let data = data else {
                DispatchQueue.main.async {
                    completion(nil)
                }
                return
            }
            
            // 解析 JSON
            do {
                let decoder = JSONDecoder()
                let productData = try decoder.decode(ProductData.self, from: data)
                
                let product = Product(
                    id: productData.id,
                    name: productData.name,
                    price: productData.price,
                    imageUrl: productData.imageUrl,
                    description: productData.description
                )
                
                DispatchQueue.main.async {
                    print("✅ 获取商品成功：\(product.name)")
                    completion(product)
                }
            } catch {
                print("❌ JSON 解析错误：\(error)")
                DispatchQueue.main.async {
                    completion(nil)
                }
            }
        }.resume()
    }
    
    /// 获取商品列表（网络请求）
    func getProductList(category: String?, completion: @escaping ([Product]) -> Void) {
        print("🌐 网络请求：获取商品列表")
        
        var urlString = "https://api.example.com/products"
        if let category = category {
            urlString += "?category=\(category)"
        }
        
        guard let url = URL(string: urlString) else {
            completion([])
            return
        }
        
        URLSession.shared.dataTask(with: url) { data, response, error in
            guard let data = data, error == nil else {
                DispatchQueue.main.async {
                    completion([])
                }
                return
            }
            
            do {
                let decoder = JSONDecoder()
                let productList = try decoder.decode([ProductData].self, from: data)
                
                let products = productList.map { productData in
                    Product(
                        id: productData.id,
                        name: productData.name,
                        price: productData.price,
                        imageUrl: productData.imageUrl,
                        description: productData.description
                    )
                }
                
                DispatchQueue.main.async {
                    print("✅ 获取商品列表成功：\(products.count) 个")
                    completion(products)
                }
            } catch {
                DispatchQueue.main.async {
                    completion([])
                }
            }
        }.resume()
    }
}

// MARK: - 数据模型（用于 JSON 解析）

struct ProductData: Codable {
    let id: String
    let name: String
    let price: Double
    let imageUrl: String?
    let description: String?
}
```

---

### 方式 2：抽取网络层 + 依赖注入（推荐）

#### 2.1 创建网络服务协议

```swift
// NetworkService.swift

/// 网络服务协议
protocol NetworkServiceProtocol {
    /// 通用 GET 请求
    func get<T: Codable>(
        url: String,
        parameters: [String: Any]?,
        completion: @escaping (Result<T, Error>) -> Void
    )
    
    /// 通用 POST 请求
    func post<T: Codable>(
        url: String,
        body: [String: Any]?,
        completion: @escaping (Result<T, Error>) -> Void
    )
}

/// 网络错误
enum NetworkError: Error {
    case invalidURL
    case noData
    case decodingError
    case serverError(String)
}

/// 网络服务实现
class NetworkService: NetworkServiceProtocol {
    
    static let shared = NetworkService()
    
    private init() {}
    
    func get<T: Codable>(
        url: String,
        parameters: [String: Any]? = nil,
        completion: @escaping (Result<T, Error>) -> Void
    ) {
        // 构建 URL
        var urlComponents = URLComponents(string: url)
        
        if let parameters = parameters {
            urlComponents?.queryItems = parameters.map {
                URLQueryItem(name: $0.key, value: "\($0.value)")
            }
        }
        
        guard let finalURL = urlComponents?.url else {
            DispatchQueue.main.async {
                completion(.failure(NetworkError.invalidURL))
            }
            return
        }
        
        // 发起请求
        URLSession.shared.dataTask(with: finalURL) { data, response, error in
            if let error = error {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
                return
            }
            
            guard let data = data else {
                DispatchQueue.main.async {
                    completion(.failure(NetworkError.noData))
                }
                return
            }
            
            // 解析 JSON
            do {
                let decoder = JSONDecoder()
                let result = try decoder.decode(T.self, from: data)
                DispatchQueue.main.async {
                    completion(.success(result))
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(NetworkError.decodingError))
                }
            }
        }.resume()
    }
    
    func post<T: Codable>(
        url: String,
        body: [String: Any]? = nil,
        completion: @escaping (Result<T, Error>) -> Void
    ) {
        guard let finalURL = URL(string: url) else {
            DispatchQueue.main.async {
                completion(.failure(NetworkError.invalidURL))
            }
            return
        }
        
        var request = URLRequest(url: finalURL)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        if let body = body {
            request.httpBody = try? JSONSerialization.data(withJSONObject: body)
        }
        
        URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
                return
            }
            
            guard let data = data else {
                DispatchQueue.main.async {
                    completion(.failure(NetworkError.noData))
                }
                return
            }
            
            do {
                let decoder = JSONDecoder()
                let result = try decoder.decode(T.self, from: data)
                DispatchQueue.main.async {
                    completion(.success(result))
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }.resume()
    }
}
```

#### 2.2 在模块中使用网络服务（依赖注入）

```swift
// ProductModule.swift

class ProductModule: ProductModuleProtocol {
    static let moduleName = "ProductModule"
    
    // 依赖注入：网络服务
    var networkService: NetworkServiceProtocol = NetworkService.shared
    
    required init() {}
    
    // MARK: - 服务方法
    
    /// 获取商品信息（使用注入的网络服务）
    func getProduct(productId: String, completion: @escaping (Product?) -> Void) {
        print("🌐 网络请求：获取商品 \(productId)")
        
        let url = "https://api.example.com/products/\(productId)"
        
        networkService.get(url: url, parameters: nil) { (result: Result<ProductData, Error>) in
            switch result {
            case .success(let productData):
                let product = Product(
                    id: productData.id,
                    name: productData.name,
                    price: productData.price,
                    imageUrl: productData.imageUrl,
                    description: productData.description
                )
                print("✅ 获取商品成功：\(product.name)")
                completion(product)
                
            case .failure(let error):
                print("❌ 获取商品失败：\(error.localizedDescription)")
                completion(nil)
            }
        }
    }
    
    /// 获取商品列表
    func getProductList(category: String?, completion: @escaping ([Product]) -> Void) {
        print("🌐 网络请求：获取商品列表")
        
        let url = "https://api.example.com/products"
        var parameters: [String: Any]? = nil
        
        if let category = category {
            parameters = ["category": category]
        }
        
        networkService.get(url: url, parameters: parameters) { (result: Result<[ProductData], Error>) in
            switch result {
            case .success(let productDataList):
                let products = productDataList.map { productData in
                    Product(
                        id: productData.id,
                        name: productData.name,
                        price: productData.price,
                        imageUrl: productData.imageUrl,
                        description: productData.description
                    )
                }
                print("✅ 获取商品列表成功：\(products.count) 个")
                completion(products)
                
            case .failure(let error):
                print("❌ 获取商品列表失败：\(error.localizedDescription)")
                completion([])
            }
        }
    }
    
    /// 搜索商品
    func searchProducts(keyword: String, completion: @escaping ([Product]) -> Void) {
        print("🌐 网络请求：搜索商品 \(keyword)")
        
        let url = "https://api.example.com/products/search"
        let parameters = ["keyword": keyword]
        
        networkService.get(url: url, parameters: parameters) { (result: Result<[ProductData], Error>) in
            switch result {
            case .success(let productDataList):
                let products = productDataList.map { Product(id: $0.id, name: $0.name, price: $0.price, imageUrl: $0.imageUrl, description: $0.description) }
                completion(products)
                
            case .failure:
                completion([])
            }
        }
    }
}
```

---

### 方式 3：使用第三方网络库（Alamofire）

```swift
import Alamofire

class ProductModule: ProductModuleProtocol {
    static let moduleName = "ProductModule"
    
    required init() {}
    
    // MARK: - 使用 Alamofire
    
    func getProduct(productId: String, completion: @escaping (Product?) -> Void) {
        let url = "https://api.example.com/products/\(productId)"
        
        AF.request(url)
            .validate()
            .responseDecodable(of: ProductData.self) { response in
                switch response.result {
                case .success(let productData):
                    let product = Product(
                        id: productData.id,
                        name: productData.name,
                        price: productData.price,
                        imageUrl: productData.imageUrl,
                        description: productData.description
                    )
                    completion(product)
                    
                case .failure(let error):
                    print("❌ 网络错误：\(error)")
                    completion(nil)
                }
            }
    }
    
    func getProductList(category: String?, completion: @escaping ([Product]) -> Void) {
        let url = "https://api.example.com/products"
        var parameters: Parameters = [:]
        
        if let category = category {
            parameters["category"] = category
        }
        
        AF.request(url, parameters: parameters)
            .validate()
            .responseDecodable(of: [ProductData].self) { response in
                switch response.result {
                case .success(let productDataList):
                    let products = productDataList.map { Product(id: $0.id, name: $0.name, price: $0.price, imageUrl: $0.imageUrl, description: $0.description) }
                    completion(products)
                    
                case .failure:
                    completion([])
                }
            }
    }
}
```

---

## 🎯 最佳实践

### 1. 协议分离（推荐）

```swift
/// 商品模块协议
protocol ProductModuleProtocol: PageModuleProtocol, ServiceModuleProtocol {
    
    // MARK: - 页面创建
    func createProductDetailPage(productId: String) -> UIViewController?
    func createProductListPage(category: String?) -> UIViewController?
    
    // MARK: - 本地服务（不涉及网络）
    func addToCart(productId: String, quantity: Int) -> Bool
    func favoriteProduct(productId: String) -> Bool
    
    // MARK: - 网络服务
    func getProduct(productId: String, completion: @escaping (Product?) -> Void)
    func getProductList(category: String?, completion: @escaping ([Product]) -> Void)
    func searchProducts(keyword: String, completion: @escaping ([Product]) -> Void)
}
```

### 2. 依赖注入

```swift
class ProductModule: ProductModuleProtocol {
    // 注入网络服务（便于测试和替换）
    var networkService: NetworkServiceProtocol
    
    // 注入数据存储（便于测试）
    var storage: StorageProtocol
    
    // 可以有默认值
    init(
        networkService: NetworkServiceProtocol = NetworkService.shared,
        storage: StorageProtocol = UserDefaults.standard
    ) {
        self.networkService = networkService
        self.storage = storage
    }
    
    // ModuleProtocol 要求的初始化方法
    required convenience init() {
        self.init(
            networkService: NetworkService.shared,
            storage: UserDefaults.standard
        )
    }
}
```

### 3. 错误处理

```swift
/// 商品模块错误
enum ProductModuleError: Error {
    case networkError(Error)
    case invalidProductId
    case productNotFound
    case serverError(String)
    
    var localizedDescription: String {
        switch self {
        case .networkError(let error):
            return "网络错误：\(error.localizedDescription)"
        case .invalidProductId:
            return "无效的商品ID"
        case .productNotFound:
            return "商品不存在"
        case .serverError(let message):
            return "服务器错误：\(message)"
        }
    }
}

// 使用 Result
func getProduct(productId: String, completion: @escaping (Result<Product, ProductModuleError>) -> Void) {
    guard !productId.isEmpty else {
        completion(.failure(.invalidProductId))
        return
    }
    
    networkService.get(url: "...") { (result: Result<ProductData, Error>) in
        switch result {
        case .success(let data):
            let product = Product(id: data.id, name: data.name, price: data.price)
            completion(.success(product))
            
        case .failure(let error):
            completion(.failure(.networkError(error)))
        }
    }
}
```

### 4. 缓存策略

```swift
class ProductModule: ProductModuleProtocol {
    // 内存缓存
    private var cache: [String: Product] = [:]
    
    func getProduct(productId: String, completion: @escaping (Product?) -> Void) {
        // 1. 先检查缓存
        if let cachedProduct = cache[productId] {
            print("✅ 从缓存获取商品：\(cachedProduct.name)")
            completion(cachedProduct)
            return
        }
        
        // 2. 发起网络请求
        print("🌐 从网络获取商品：\(productId)")
        networkService.get(url: "...") { [weak self] (result: Result<ProductData, Error>) in
            switch result {
            case .success(let data):
                let product = Product(id: data.id, name: data.name, price: data.price)
                
                // 3. 存入缓存
                self?.cache[productId] = product
                
                completion(product)
                
            case .failure:
                completion(nil)
            }
        }
    }
}
```

---

## 📱 完整示例

### ProductModule 完整实现（包含网络请求）

```swift
// ProductModule.swift

import Foundation

class ProductModule: ProductModuleProtocol {
    static let moduleName = "ProductModule"
    
    // 依赖注入
    var networkService: NetworkServiceProtocol = NetworkService.shared
    
    // 缓存
    private var cache: [String: Product] = [:]
    
    // 购物车（本地）
    private var cart: [String: Int] = [:]
    
    required init() {}
    
    // MARK: - PageModuleProtocol
    
    func createViewController(with parameters: [String : Any]) -> UIViewController? {
        if let productId = parameters["productId"] as? String {
            return createProductDetailPage(productId: productId)
        } else {
            let category = parameters["category"] as? String
            return createProductListPage(category: category)
        }
    }
    
    // MARK: - 页面创建
    
    func createProductDetailPage(productId: String) -> UIViewController? {
        let vc = ModuleProductDetailViewController()
        vc.productId = productId
        return vc
    }
    
    func createProductListPage(category: String?) -> UIViewController? {
        let vc = ModuleProductListViewController()
        vc.category = category
        return vc
    }
    
    // MARK: - 网络服务
    
    /// 获取商品信息（网络请求 + 缓存）
    func getProduct(productId: String, completion: @escaping (Product?) -> Void) {
        // 1. 检查缓存
        if let cachedProduct = cache[productId] {
            print("✅ 从缓存获取商品：\(cachedProduct.name)")
            completion(cachedProduct)
            return
        }
        
        // 2. 网络请求
        print("🌐 网络请求：获取商品 \(productId)")
        
        let url = "https://api.example.com/products/\(productId)"
        
        networkService.get(url: url, parameters: nil) { [weak self] (result: Result<ProductData, Error>) in
            switch result {
            case .success(let productData):
                let product = Product(
                    id: productData.id,
                    name: productData.name,
                    price: productData.price,
                    imageUrl: productData.imageUrl,
                    description: productData.description
                )
                
                // 3. 存入缓存
                self?.cache[productId] = product
                
                print("✅ 获取商品成功：\(product.name)")
                completion(product)
                
            case .failure(let error):
                print("❌ 获取商品失败：\(error.localizedDescription)")
                completion(nil)
            }
        }
    }
    
    /// 获取商品列表（网络请求）
    func getProductList(category: String?, completion: @escaping ([Product]) -> Void) {
        print("🌐 网络请求：获取商品列表")
        
        let url = "https://api.example.com/products"
        var parameters: [String: Any]? = nil
        
        if let category = category {
            parameters = ["category": category]
        }
        
        networkService.get(url: url, parameters: parameters) { (result: Result<[ProductData], Error>) in
            switch result {
            case .success(let productDataList):
                let products = productDataList.map { productData in
                    Product(
                        id: productData.id,
                        name: productData.name,
                        price: productData.price,
                        imageUrl: productData.imageUrl,
                        description: productData.description
                    )
                }
                print("✅ 获取商品列表成功：\(products.count) 个")
                completion(products)
                
            case .failure(let error):
                print("❌ 获取商品列表失败：\(error.localizedDescription)")
                completion([])
            }
        }
    }
    
    /// 搜索商品（网络请求）
    func searchProducts(keyword: String, completion: @escaping ([Product]) -> Void) {
        print("🌐 网络请求：搜索商品 \(keyword)")
        
        let url = "https://api.example.com/products/search"
        let parameters = ["keyword": keyword]
        
        networkService.get(url: url, parameters: parameters) { (result: Result<[ProductData], Error>) in
            switch result {
            case .success(let productDataList):
                let products = productDataList.map { Product(id: $0.id, name: $0.name, price: $0.price, imageUrl: $0.imageUrl, description: $0.description) }
                completion(products)
                
            case .failure:
                completion([])
            }
        }
    }
    
    // MARK: - 本地服务
    
    func addToCart(productId: String, quantity: Int) -> Bool {
        print("🛒 添加到购物车：\(productId) x\(quantity)")
        
        if let currentQuantity = cart[productId] {
            cart[productId] = currentQuantity + quantity
        } else {
            cart[productId] = quantity
        }
        
        return true
    }
    
    func favoriteProduct(productId: String) -> Bool {
        print("❤️ 收藏商品：\(productId)")
        return true
    }
}
```

---

## 🎯 优势总结

### Protocol-Based Router 支持网络请求的优势

1. **完整的业务单元**
   - 模块包含页面 + 业务逻辑 + 网络请求
   - 高内聚，易维护

2. **依赖注入**
   - 网络服务可以注入
   - 便于单元测试（Mock Network）

3. **类型安全**
   - 接口明确定义
   - 编译时检查

4. **解耦**
   - 其他模块通过协议调用服务
   - 无需知道实现细节

5. **易于测试**
   ```swift
   // 测试时注入 Mock 网络服务
   let mockNetwork = MockNetworkService()
   let productModule = ProductModule(networkService: mockNetwork)
   ```

---

## ✅ 总结

在 Protocol-Based Router 方案中：

✅ **完全支持网络请求**  
✅ **推荐使用依赖注入**  
✅ **网络层可以复用**  
✅ **支持缓存策略**  
✅ **易于单元测试**  

这是一个完整的业务模块方案，不仅仅是页面路由！

