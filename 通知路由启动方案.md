# 通知路由启动方案

## 📱 问题场景

### 场景描述

当 App **完全未启动**或**已被杀死**时：
```
用户收到推送通知 → 点击通知 → 启动 App → 跳转到指定页面
```

### 核心问题

```
❌ 问题：
1. App 启动时，Window 和 RootViewController 还未初始化
2. Router.open() 需要 currentViewController，但此时可能还没有
3. 路由调用时机太早，UI 还未准备好

✅ 解决：
使用"延迟路由"机制，等 UI 初始化完成后再执行路由
```

---

## 🎯 解决方案架构

### 1. 延迟路由机制

```swift
Router.shared
    ↓
启动时保存待处理的 URL
    ↓
等待 UI 初始化完成
    ↓
执行延迟的路由
```

### 2. 生命周期时序

```
App 完全未启动：
1. AppDelegate.didFinishLaunching → 保存通知 URL
2. SceneDelegate.willConnectTo → 创建 Window
3. RootViewController.viewDidAppear → UI 就绪
4. 执行延迟路由 ✅

App 在后台：
1. 用户点击通知
2. AppDelegate.didReceiveRemoteNotification
3. 直接执行路由（UI 已就绪）✅

App 在前台：
1. 收到通知
2. 用户点击通知（或 banner）
3. 直接执行路由 ✅
```

---

## 💻 代码实现

### 1. Router.swift - 添加延迟路由支持

```swift
// MARK: - 延迟路由（用于启动场景）

/// 待处理的路由（App 启动时可能 UI 还未就绪）
private var pendingURLString: String?
private var pendingParameters: [String: Any]?

/// 设置待处理的路由（在 UI 就绪前调用）
/// 通常在 AppDelegate.didFinishLaunching 中调用
func setPendingRoute(_ urlString: String, parameters: [String: Any] = [:]) {
    print("📌 设置待处理路由：\(urlString)")
    pendingURLString = urlString
    pendingParameters = parameters
}

/// 执行待处理的路由（在 UI 就绪后调用）
/// 通常在 RootViewController.viewDidAppear 中调用
@discardableResult
func executePendingRoute() -> Bool {
    guard let urlString = pendingURLString else {
        return false
    }
    
    print("🚀 执行待处理路由：\(urlString)")
    
    let parameters = pendingParameters ?? [:]
    
    // 清除待处理的路由
    pendingURLString = nil
    pendingParameters = nil
    
    // 延迟执行，确保 UI 完全就绪
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
        self?.open(urlString, parameters: parameters)
    }
    
    return true
}

/// 是否有待处理的路由
var hasPendingRoute: Bool {
    return pendingURLString != nil
}
```

---

### 2. AppDelegate.swift - 处理通知启动

```swift
import UIKit
import UserNotifications

@main
class AppDelegate: UIResponder, UIApplicationDelegate {

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        
        // 1. 注册路由
        registerAllRoutes()
        
        // 2. 请求通知权限
        requestNotificationPermission()
        
        // 3. 处理从通知启动的情况
        handleLaunchFromNotification(launchOptions: launchOptions)
        
        return true
    }
    
    // MARK: - 路由注册
    
    private func registerAllRoutes() {
        let router = Router.shared
        
        router.register("app://user/:userId", viewControllerType: RouteUserDetailViewController.self)
        router.register("app://settings", action: .present) { _ in
            let vc = RouteSettingsViewController()
            return UINavigationController(rootViewController: vc)
        }
        router.register("app://product/:productId", viewControllerType: RouteProductViewController.self)
        router.register("app://search", viewControllerType: RouteSearchViewController.self)
        router.register("app://vip/:vipId", viewControllerType: RouteVIPViewController.self)
        
        // 通知详情页（新增）
        router.register("app://notification/:notificationId", viewControllerType: RouteNotificationDetailViewController.self)
        
        print("✅ 应用启动时已注册所有路由")
    }
    
    // MARK: - 通知处理
    
    /// 请求通知权限
    private func requestNotificationPermission() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
            if granted {
                print("✅ 通知权限已授予")
                DispatchQueue.main.async {
                    UIApplication.shared.registerForRemoteNotifications()
                }
            } else {
                print("❌ 通知权限被拒绝：\(error?.localizedDescription ?? "")")
            }
        }
        
        // 设置通知代理
        UNUserNotificationCenter.current().delegate = self
    }
    
    /// 处理从通知启动（App 完全未运行时）
    private func handleLaunchFromNotification(launchOptions: [UIApplication.LaunchOptionsKey: Any]?) {
        
        // 场景1：从远程推送通知启动
        if let remoteNotification = launchOptions?[.remoteNotification] as? [AnyHashable: Any] {
            print("🔔 从远程通知启动 App")
            handleNotificationPayload(remoteNotification, isLaunch: true)
        }
        
        // 场景2：从本地通知启动
        if let localNotification = launchOptions?[.localNotification] as? UILocalNotification {
            print("🔔 从本地通知启动 App")
            if let userInfo = localNotification.userInfo {
                handleNotificationPayload(userInfo, isLaunch: true)
            }
        }
    }
    
    /// 处理通知负载（提取路由信息）
    private func handleNotificationPayload(_ userInfo: [AnyHashable: Any], isLaunch: Bool) {
        print("📦 通知内容：\(userInfo)")
        
        // 从通知中提取路由信息
        // 格式示例：{"route": "app://product/123", "title": "新商品上架"}
        
        guard let routeString = userInfo["route"] as? String else {
            print("⚠️ 通知中没有路由信息")
            return
        }
        
        print("🔗 提取到路由：\(routeString)")
        
        // 提取额外参数
        var parameters: [String: Any] = [:]
        if let params = userInfo["parameters"] as? [String: Any] {
            parameters = params
        }
        
        if isLaunch {
            // App 启动场景：设置待处理路由
            print("📌 App 正在启动，设置待处理路由")
            Router.shared.setPendingRoute(routeString, parameters: parameters)
        } else {
            // App 已运行场景：直接执行路由
            print("🚀 App 已运行，直接执行路由")
            Router.shared.open(routeString, parameters: parameters)
        }
    }
    
    // MARK: - 远程推送（App 在后台或前台时）
    
    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable: Any]) {
        print("🔔 收到远程推送通知（App 在后台或前台）")
        handleNotificationPayload(userInfo, isLaunch: false)
    }
    
    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable: Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
        print("🔔 收到远程推送通知（后台刷新）")
        handleNotificationPayload(userInfo, isLaunch: false)
        completionHandler(.newData)
    }
    
    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        let token = deviceToken.map { String(format: "%02.2hhx", $0) }.joined()
        print("✅ 获取到 Device Token: \(token)")
        // 这里应该将 token 发送到你的服务器
    }
    
    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        print("❌ 注册远程通知失败：\(error.localizedDescription)")
    }
    
    // MARK: - URL Scheme（外部唤起）
    
    func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
        print("🔗 通过 URL Scheme 打开：\(url)")
        
        // 检查 UI 是否就绪
        if Router.shared.currentViewController() != nil {
            // UI 已就绪，直接执行
            return Router.shared.open(url)
        } else {
            // UI 未就绪，设置待处理路由
            Router.shared.setPendingRoute(url.absoluteString)
            return true
        }
    }
}

// MARK: - UNUserNotificationCenterDelegate

extension AppDelegate: UNUserNotificationCenterDelegate {
    
    /// 前台收到通知
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        print("🔔 前台收到通知：\(notification.request.content.userInfo)")
        
        // iOS 14+ 显示 banner
        if #available(iOS 14.0, *) {
            completionHandler([.banner, .sound, .badge])
        } else {
            completionHandler([.alert, .sound, .badge])
        }
    }
    
    /// 用户点击通知
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
        print("🔔 用户点击了通知")
        
        let userInfo = response.notification.request.content.userInfo
        
        // 检查 App 是否刚启动
        let isLaunch = Router.shared.currentViewController() == nil
        
        handleNotificationPayload(userInfo, isLaunch: isLaunch)
        
        completionHandler()
    }
}
```

---

### 3. SceneDelegate.swift - 处理多场景

```swift
import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        guard let windowScene = (scene as? UIWindowScene) else { return }
        
        // 创建窗口和根视图控制器
        window = UIWindow(windowScene: windowScene)
        
        let storyboard = UIStoryboard(name: "Main", bundle: nil)
        let rootVC = storyboard.instantiateInitialViewController()
        
        window?.rootViewController = rootVC
        window?.makeKeyAndVisible()
        
        // 处理从通知或 URL 启动
        handleConnectionOptions(connectionOptions)
    }
    
    /// 处理场景连接选项
    private func handleConnectionOptions(_ connectionOptions: UIScene.ConnectionOptions) {
        
        // 从通知启动
        if let notificationResponse = connectionOptions.notificationResponse {
            print("🔔 Scene 从通知响应启动")
            let userInfo = notificationResponse.notification.request.content.userInfo
            handleNotificationPayload(userInfo)
        }
        
        // 从 URL 启动
        if let urlContext = connectionOptions.urlContexts.first {
            print("🔗 Scene 从 URL 启动：\(urlContext.url)")
            Router.shared.setPendingRoute(urlContext.url.absoluteString)
        }
    }
    
    /// 处理通知负载
    private func handleNotificationPayload(_ userInfo: [AnyHashable: Any]) {
        guard let routeString = userInfo["route"] as? String else {
            return
        }
        
        var parameters: [String: Any] = [:]
        if let params = userInfo["parameters"] as? [String: Any] {
            parameters = params
        }
        
        Router.shared.setPendingRoute(routeString, parameters: parameters)
    }
    
    /// Scene 进入前台（从后台恢复）
    func sceneDidBecomeActive(_ scene: UIScene) {
        print("🔄 Scene 已激活")
    }
}
```

---

### 4. HomeViewController.swift - 执行延迟路由

```swift
class HomeViewController: UIViewController {
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        // 执行待处理的路由（如果有）
        if Router.shared.hasPendingRoute {
            print("🚀 HomeViewController 已就绪，执行待处理路由")
            Router.shared.executePendingRoute()
        }
    }
}
```

---

### 5. 通知详情页（示例）

```swift
// RoutePages.swift 中添加

// MARK: - 通知详情页

class RouteNotificationDetailViewController: UIViewController, Routable {
    var notificationId: String?
    var message: String?
    
    static func instantiate(with parameters: [String : Any]) -> Self? {
        let vc = Self()
        vc.notificationId = parameters["notificationId"] as? String
        vc.message = parameters["message"] as? String
        return vc
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        title = "通知详情"
        view.backgroundColor = .systemBackground
        
        let label = UILabel()
        label.text = """
        通知 ID：\(notificationId ?? "未知")
        消息：\(message ?? "无")
        
        🎉 从通知启动成功！
        """
        label.font = .systemFont(ofSize: 18, weight: .medium)
        label.textAlignment = .center
        label.numberOfLines = 0
        label.translatesAutoresizingMaskIntoConstraints = false
        
        view.addSubview(label)
        
        NSLayoutConstraint.activate([
            label.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            label.centerYAnchor.constraint(equalTo: view.centerYAnchor),
            label.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            label.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20)
        ])
    }
}
```

---

## 📱 通知负载格式

### 推送通知 JSON 格式

```json
{
  "aps": {
    "alert": {
      "title": "新商品上架",
      "body": "iPhone 16 Pro 现已开售"
    },
    "badge": 1,
    "sound": "default"
  },
  "route": "app://product/12345",
  "parameters": {
    "name": "iPhone 16 Pro",
    "price": "7999"
  }
}
```

### 本地通知示例

```swift
func scheduleLocalNotification() {
    let content = UNMutableNotificationContent()
    content.title = "测试通知"
    content.body = "点击查看商品详情"
    content.sound = .default
    
    // 添加路由信息
    content.userInfo = [
        "route": "app://product/8888",
        "parameters": [
            "name": "测试商品",
            "price": "99"
        ]
    ]
    
    // 5秒后触发
    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)
    
    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
    
    UNUserNotificationCenter.current().add(request) { error in
        if let error = error {
            print("❌ 添加通知失败：\(error)")
        } else {
            print("✅ 通知已调度")
        }
    }
}
```

---

## 🎯 所有启动场景处理

### 场景 1：App 完全未启动 + 点击通知

```
1. 用户点击通知
2. AppDelegate.didFinishLaunching
   - 注册路由
   - handleLaunchFromNotification
   - Router.setPendingRoute() ✅
3. SceneDelegate.willConnectTo
   - 创建 Window
4. HomeViewController.viewDidAppear
   - Router.executePendingRoute() ✅
5. 跳转到目标页面 ✅
```

### 场景 2：App 在后台 + 点击通知

```
1. 用户点击通知
2. UNUserNotificationCenterDelegate.didReceive
   - currentViewController != nil（已就绪）
   - Router.open() 直接执行 ✅
3. 跳转到目标页面 ✅
```

### 场景 3：App 在前台 + 收到通知

```
1. 收到通知
2. UNUserNotificationCenterDelegate.willPresent
   - 显示 banner
3. 用户点击 banner
4. didReceive 响应
5. Router.open() 直接执行 ✅
```

### 场景 4：通过 URL Scheme 启动

```
myapp://product/123

1. AppDelegate.application(_:open:options:)
2. 检查 currentViewController
3. 如果 nil → setPendingRoute()
4. 如果有 → 直接 open()
```

---

## 🧪 测试方法

### 1. 测试本地通知启动

在 Router 演示页面添加按钮：

```swift
// RouterDemoViewController.swift

@objc private func testNotification() {
    log("📤 发送本地通知（5秒后）")
    
    let content = UNMutableNotificationContent()
    content.title = "测试路由"
    content.body = "点击查看 VIP 页面"
    content.sound = .default
    content.userInfo = [
        "route": "app://vip/999",
        "parameters": ["from": "notification"]
    ]
    
    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)
    let request = UNNotificationRequest(identifier: "test", content: content, trigger: trigger)
    
    UNUserNotificationCenter.current().add(request) { error in
        if error == nil {
            DispatchQueue.main.async { [weak self] in
                self?.log("✅ 通知已发送，请等待 5 秒")
            }
        }
    }
}
```

### 2. 测试步骤

```
步骤 1：测试前台通知
1. 运行 App
2. 点击 [发送测试通知]
3. 等待 5 秒
4. 点击通知 banner
5. ✅ 应该跳转到 VIP 页面

步骤 2：测试后台启动
1. 运行 App
2. 点击 [发送测试通知]
3. 按 Home 键（App 进入后台）
4. 等待通知出现
5. 点击通知
6. ✅ App 回到前台并跳转

步骤 3：测试完全启动
1. 运行 App
2. 点击 [发送测试通知]
3. 从多任务管理器完全杀死 App
4. 等待通知出现
5. 点击通知
6. ✅ App 启动并跳转到 VIP 页面
```

---

## 💡 最佳实践

### 1. 路由延迟执行

```swift
✅ 好：等待 UI 就绪
Router.shared.setPendingRoute(...)
// 在 viewDidAppear 中执行

❌ 差：立即执行
Router.shared.open(...)  // Window 可能还没创建
```

### 2. 通知权限

```swift
// 在 AppDelegate 启动时请求
func application(...) -> Bool {
    requestNotificationPermission()
    return true
}
```

### 3. 通知负载设计

```swift
✅ 好：包含完整路由信息
{
  "route": "app://product/123",
  "parameters": {...}
}

❌ 差：只有 ID，需要额外查询
{
  "productId": "123"  // 需要业务层处理
}
```

### 4. 多次延迟路由

```swift
// 只保留最新的待处理路由
func setPendingRoute(...) {
    if pendingURLString != nil {
        print("⚠️ 覆盖之前的待处理路由")
    }
    pendingURLString = urlString
}
```

---

## 🔍 调试技巧

### 1. 日志追踪

在所有关键点添加日志：
```swift
print("🔔 [Notification] 收到通知")
print("📌 [Router] 设置待处理路由")
print("🚀 [Router] 执行待处理路由")
print("✅ [Router] 路由执行完成")
```

### 2. 模拟器测试

```bash
# 模拟推送通知（需要 Xcode 11.4+）
xcrun simctl push booted com.yourcompany.jiagou notification.json
```

### 3. Xcode 断点

在以下位置设置断点：
- `setPendingRoute`
- `executePendingRoute`
- `didReceive response`

---

## ✅ 完整清单

实现通知路由启动需要：

- [ ] Router 添加 `setPendingRoute()` 和 `executePendingRoute()`
- [ ] AppDelegate 处理通知启动场景
- [ ] AppDelegate 实现 `UNUserNotificationCenterDelegate`
- [ ] SceneDelegate 处理场景连接选项
- [ ] HomeViewController 在 `viewDidAppear` 执行延迟路由
- [ ] 定义通知负载格式（包含 route 字段）
- [ ] 请求通知权限
- [ ] 添加测试按钮和方法
- [ ] 测试所有启动场景

---

**实现完成后，无论 App 处于何种状态，都能通过通知正确跳转！🎉**

