# 日志框架演示使用说明

## 📝 功能概述

本项目包含完整的日志框架实现，提供多级别、多输出目标的日志系统，适用于企业级应用开发。

**核心特性**:
- ✅ 六种日志级别（VERBOSE、DEBUG、INFO、WARNING、ERROR、FATAL）
- ✅ 多输出目标（控制台、文件、远程服务器）
- ✅ 自定义日志格式化器
- ✅ 日志文件轮转（自动管理文件大小）
- ✅ 线程安全
- ✅ 丰富的元数据（时间戳、文件名、行号、线程信息）

---

## 🚀 快速启动

### 从主页进入

1. 运行项目
2. 在主页找到 **"日志框架"** 按钮（绿色）
3. 点击进入日志框架演示界面

### 代码启动

```swift
let loggerVC = LoggerDemoViewController()
navigationController?.pushViewController(loggerVC, animated: true)
```

---

## 📊 功能演示

### 1. 日志级别演示

点击不同的按钮记录不同级别的日志：

| 按钮 | 日志级别 | 使用场景 | 颜色 |
|------|---------|---------|------|
| 💬 VERBOSE | 详细日志 | 开发调试、详细追踪 | 灰色 |
| 🐛 DEBUG | 调试日志 | 开发环境、问题排查 | 蓝色 |
| ℹ️ INFO | 信息日志 | 正常信息、关键步骤 | 绿色 |
| ⚠️ WARNING | 警告日志 | 潜在问题、性能警告 | 黄色 |
| ❌ ERROR | 错误日志 | 错误信息、异常捕获 | 红色 |
| 💀 FATAL | 致命错误 | 严重错误、崩溃前 | 紫色 |

### 2. 功能按钮

| 按钮 | 功能说明 |
|------|---------|
| 🗑️ 清除日志 | 清空显示区域的日志内容 |
| 💾 保存到文件 | 启用文件日志输出，日志保存到本地文件 |

---

## 🏗️ 架构说明

### 核心组件

```
┌─────────────────────────────────────┐
│            Logger                   │
│         (日志管理器)                 │
└──────────────┬──────────────────────┘
               │ 分发日志
               ↓
┌──────────────────────────────────────┐
│        LogDestination               │
│      (日志输出目标协议)               │
├──────────────────────────────────────┤
│  • ConsoleLogDestination (控制台)   │
│  • FileLogDestination (文件)        │
│  • RemoteLogDestination (远程)      │
└──────────────┬───────────────────────┘
               │ 格式化
               ↓
┌──────────────────────────────────────┐
│        LogFormatter                 │
│      (日志格式化器协议)               │
├──────────────────────────────────────┤
│  • DefaultLogFormatter (默认)       │
│  • SimpleLogFormatter (简单)        │
│  • JSONLogFormatter (JSON)          │
└──────────────────────────────────────┘
```

---

## 💻 代码使用示例

### 基本使用

```swift
// 1. 记录不同级别的日志
logVerbose("详细信息：变量 x = 10")
logDebug("开始处理用户请求")
logInfo("用户登录成功：user_id = 123")
logWarning("网络连接不稳定")
logError("文件读取失败：file not found")
logFatal("数据库连接丢失")

// 2. 使用 Logger 单例
Logger.shared.verbose("详细日志")
Logger.shared.debug("调试日志")
Logger.shared.info("信息日志")
Logger.shared.warning("警告日志")
Logger.shared.error("错误日志")
Logger.shared.fatal("致命错误")
```

### 自定义配置

```swift
// 1. 设置全局最低日志级别
Logger.shared.minLevel = .info  // 只输出 INFO 及以上级别

// 2. 添加文件输出
let fileDestination = FileLogDestination()
fileDestination.minLevel = .warning  // 只保存警告及以上级别到文件
Logger.shared.addDestination(fileDestination)

// 3. 添加远程日志输出
let remoteDestination = RemoteLogDestination(
    serverURL: "https://api.example.com/logs"
)
remoteDestination.minLevel = .error  // 只上报错误到服务器
Logger.shared.addDestination(remoteDestination)

// 4. 自定义格式化器
let simpleFormatter = SimpleLogFormatter()
let consoleDestination = ConsoleLogDestination()
consoleDestination.formatter = simpleFormatter
```

### 日志输出格式

#### 默认格式化器 (DefaultLogFormatter)

```
[2025-10-16 18:30:45.123] [ℹ️ INFO] [main] [HomeViewController.swift:42 viewDidLoad()] 用户登录成功
```

包含信息：
- 时间戳（精确到毫秒）
- 日志级别（图标 + 名称）
- 线程信息
- 文件名和行号
- 函数名
- 日志消息

#### 简单格式化器 (SimpleLogFormatter)

```
ℹ️ [INFO] 用户登录成功
```

适用于：
- 生产环境
- 简洁输出
- 用户可见日志

#### JSON 格式化器 (JSONLogFormatter)

```json
{
  "level": "INFO",
  "message": "用户登录成功",
  "file": "HomeViewController.swift",
  "function": "viewDidLoad()",
  "line": 42,
  "timestamp": 1697462445.123,
  "thread": "main"
}
```

适用于：
- 日志上报
- 结构化存储
- 日志分析

---

## 🔧 高级功能

### 1. 文件日志管理

**自动轮转**:
- 单个文件最大 5MB
- 超过大小自动创建新文件
- 旧文件带时间戳重命名

**文件清理**:
- 最多保留 10 个日志文件
- 自动删除最旧的文件
- 避免占用过多存储空间

**文件路径**:
```
Documents/Logs/
  ├── app_2025-10-16.log          (当前日志)
  ├── app_2025-10-16_1697460000.log (已轮转)
  ├── app_2025-10-15.log
  └── ...
```

### 2. 远程日志上报

**缓冲机制**:
- 缓冲 10 条日志后批量上报
- 减少网络请求次数
- 支持立即刷新 `flush()`

**上报逻辑**:
```swift
// 只上报 ERROR 和 FATAL 级别
remoteDestination.minLevel = .error

// 手动触发上报
remoteDestination.flush()
```

### 3. 线程安全

**实现方式**:
```swift
private let queue = DispatchQueue(
    label: "com.jiagou.logger",
    qos: .utility,
    attributes: .concurrent
)
```

**特点**:
- 读操作使用 `sync`
- 写操作使用 `async(flags: .barrier)`
- 保证多线程环境下数据安全

### 4. 元数据自动捕获

使用 Swift 的编译时宏：

```swift
func logInfo(
    _ message: String,
    file: String = #file,      // 自动捕获文件名
    function: String = #function,  // 自动捕获函数名
    line: Int = #line          // 自动捕获行号
)
```

---

## 🎯 使用场景

### 场景1：开发调试

```swift
func processUserData(_ data: [String: Any]) {
    logDebug("开始处理用户数据")
    logVerbose("原始数据：\(data)")
    
    guard let userId = data["id"] as? String else {
        logError("用户ID缺失")
        return
    }
    
    logInfo("处理用户 ID: \(userId)")
}
```

### 场景2：错误追踪

```swift
func downloadFile(url: URL) {
    do {
        let data = try Data(contentsOf: url)
        logInfo("文件下载成功：\(url.lastPathComponent)")
    } catch {
        logError("文件下载失败：\(error.localizedDescription)")
        logError("URL: \(url.absoluteString)")
    }
}
```

### 场景3：性能监控

```swift
func performHeavyTask() {
    let startTime = Date()
    logInfo("开始执行重任务")
    
    // 执行任务
    heavyComputation()
    
    let duration = Date().timeIntervalSince(startTime)
    if duration > 1.0 {
        logWarning("任务执行时间过长：\(duration)秒")
    } else {
        logInfo("任务完成，耗时：\(duration)秒")
    }
}
```

### 场景4：生产环境监控

```swift
// AppDelegate 中配置
func application(_ application: UIApplication, didFinishLaunchingWithOptions...) {
    // 配置日志系统
    #if DEBUG
    Logger.shared.minLevel = .verbose
    #else
    Logger.shared.minLevel = .warning  // 生产环境只记录警告及以上
    
    // 添加文件日志
    let fileDestination = FileLogDestination()
    Logger.shared.addDestination(fileDestination)
    
    // 添加远程日志（只上报错误）
    let remoteDestination = RemoteLogDestination(
        serverURL: "https://api.yourserver.com/logs"
    )
    remoteDestination.minLevel = .error
    Logger.shared.addDestination(remoteDestination)
    #endif
    
    logInfo("应用启动成功")
}
```

---

## 📚 API 文档

### Logger 类

**单例访问**:
```swift
Logger.shared
```

**方法**:

| 方法 | 说明 |
|------|------|
| `verbose(_ message:)` | 记录详细日志 |
| `debug(_ message:)` | 记录调试日志 |
| `info(_ message:)` | 记录信息日志 |
| `warning(_ message:)` | 记录警告日志 |
| `error(_ message:)` | 记录错误日志 |
| `fatal(_ message:)` | 记录致命错误 |
| `addDestination(_ destination:)` | 添加输出目标 |
| `removeAllDestinations()` | 移除所有输出目标 |

**属性**:

| 属性 | 类型 | 说明 |
|------|------|------|
| `minLevel` | `LogLevel` | 全局最低日志级别 |

### LogDestination 协议

**实现类**:
- `ConsoleLogDestination` - 控制台输出
- `FileLogDestination` - 文件输出
- `RemoteLogDestination` - 远程上报

**属性**:

| 属性 | 类型 | 说明 |
|------|------|------|
| `minLevel` | `LogLevel` | 该目标的最低日志级别 |
| `formatter` | `LogFormatter` | 日志格式化器 |

### FileLogDestination 特有方法

| 方法 | 说明 |
|------|------|
| `getAllLogFiles() -> [URL]` | 获取所有日志文件 |
| `clearAllLogs()` | 清空所有日志文件 |

### RemoteLogDestination 特有方法

| 方法 | 说明 |
|------|------|
| `flush()` | 立即上报缓冲的日志 |

---

## 🎨 演示界面说明

### 主界面布局

```
┌──────────────────────────────────────┐
│        日志框架功能演示               │
├──────────────────────────────────────┤
│  日志显示区域                         │
│  ┌────────────────────────────────┐  │
│  │ [18:30:45] 💬 [VERBOSE] ...   │  │
│  │ [18:30:46] 🐛 [DEBUG] ...     │  │
│  │ [18:30:47] ℹ️ [INFO] ...      │  │
│  │                                │  │
│  └────────────────────────────────┘  │
├──────────────────────────────────────┤
│  [ 💬 记录 VERBOSE 日志 ]            │
│  [ 🐛 记录 DEBUG 日志 ]              │
│  [ ℹ️ 记录 INFO 日志 ]               │
│  [ ⚠️ 记录 WARNING 日志 ]            │
│  [ ❌ 记录 ERROR 日志 ]              │
│  [ 💀 记录 FATAL 日志 ]              │
├──────────────────────────────────────┤
│  [ 🗑️ 清除日志 ]                    │
│  [ 💾 保存到文件 ]                   │
└──────────────────────────────────────┘
```

### 操作说明

1. **记录日志**: 点击对应级别的按钮，会在显示区域和控制台输出日志
2. **清除日志**: 清空显示区域的内容（不影响已保存的文件日志）
3. **保存到文件**: 启用文件日志输出，后续日志会保存到 `Documents/Logs/` 目录

---

## 💡 最佳实践

### 1. 日志级别选择

**VERBOSE**:
```swift
logVerbose("循环第 \(i) 次，当前值：\(value)")
```
- 用于：详细的执行流程
- 场景：算法调试、数据追踪

**DEBUG**:
```swift
logDebug("进入 viewDidLoad 方法")
logDebug("网络请求参数：\(params)")
```
- 用于：开发调试信息
- 场景：开发环境、问题排查

**INFO**:
```swift
logInfo("用户登录成功：\(username)")
logInfo("下载完成：\(fileName)")
```
- 用于：重要信息记录
- 场景：关键操作、业务流程

**WARNING**:
```swift
logWarning("网络连接不稳定")
logWarning("内存使用率：\(usage)%")
```
- 用于：潜在问题提示
- 场景：性能警告、兼容性提醒

**ERROR**:
```swift
logError("文件读取失败：\(error)")
logError("API 请求失败：\(statusCode)")
```
- 用于：错误信息记录
- 场景：异常处理、错误追踪

**FATAL**:
```swift
logFatal("数据库初始化失败，应用无法继续")
logFatal("关键配置文件丢失")
```
- 用于：致命错误记录
- 场景：应用崩溃前、严重错误

### 2. 生产环境配置

```swift
// AppDelegate.swift
func application(_ application: UIApplication, didFinishLaunchingWithOptions...) {
    #if DEBUG
    // 开发环境：详细日志 + 控制台输出
    Logger.shared.minLevel = .verbose
    #else
    // 生产环境：只记录重要日志
    Logger.shared.minLevel = .warning
    
    // 移除默认的控制台输出
    Logger.shared.removeAllDestinations()
    
    // 添加文件日志
    let fileDestination = FileLogDestination()
    fileDestination.minLevel = .info
    Logger.shared.addDestination(fileDestination)
    
    // 添加远程日志（只上报错误）
    let remoteDestination = RemoteLogDestination(
        serverURL: "https://logs.yourapp.com/collect"
    )
    remoteDestination.minLevel = .error
    Logger.shared.addDestination(remoteDestination)
    #endif
}
```

### 3. 性能优化

**避免字符串插值**:
```swift
// ❌ 不好的做法（字符串总是会计算）
logDebug("复杂计算结果：\(expensiveComputation())")

// ✅ 好的做法（先检查级别）
if Logger.shared.minLevel <= .debug {
    logDebug("复杂计算结果：\(expensiveComputation())")
}
```

**使用闭包延迟计算**:
```swift
// 可以扩展 Logger 支持闭包参数
func debug(_ messageClosure: @autoclosure () -> String) {
    guard level >= minLevel else { return }
    log(.debug, messageClosure())
}
```

### 4. 错误追踪

```swift
func handleNetworkError(_ error: Error) {
    logError("网络请求失败")
    logError("错误类型：\(type(of: error))")
    logError("错误描述：\(error.localizedDescription)")
    
    if let urlError = error as? URLError {
        logError("错误代码：\(urlError.code.rawValue)")
        logError("失败 URL：\(urlError.failingURL?.absoluteString ?? "未知")")
    }
}
```

---

## 🛠️ 自定义扩展

### 创建自定义格式化器

```swift
class CustomLogFormatter: LogFormatter {
    func format(_ message: LogMessage) -> String {
        // 自定义格式：只显示时间和消息
        let time = message.formattedTimestamp.suffix(8)  // 只显示时:分:秒
        return "\(time) | \(message.level.symbol) \(message.message)"
    }
}

// 使用
let consoleDestination = ConsoleLogDestination()
consoleDestination.formatter = CustomLogFormatter()
Logger.shared.addDestination(consoleDestination)
```

### 创建自定义输出目标

```swift
class DatabaseLogDestination: LogDestination {
    var minLevel: LogLevel = .error
    var formatter: LogFormatter = JSONLogFormatter()
    
    func send(_ message: LogMessage) {
        guard message.level >= minLevel else { return }
        
        // 保存到数据库
        let logEntry = LogEntry(
            level: message.level.name,
            message: message.message,
            timestamp: message.timestamp
        )
        
        DatabaseManager.shared.insert(logEntry)
    }
}

// 使用
let dbDestination = DatabaseLogDestination()
Logger.shared.addDestination(dbDestination)
```

---

## 📖 实际应用示例

### 示例1：网络请求日志

```swift
class NetworkManager {
    func request(url: URL, completion: @escaping (Result<Data, Error>) -> Void) {
        logInfo("开始网络请求：\(url.absoluteString)")
        
        let startTime = Date()
        
        URLSession.shared.dataTask(with: url) { data, response, error in
            let duration = Date().timeIntervalSince(startTime)
            
            if let error = error {
                logError("请求失败：\(error.localizedDescription)")
                logError("URL: \(url.absoluteString)")
                logError("耗时: \(duration)秒")
                completion(.failure(error))
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse else {
                logError("无效的响应类型")
                completion(.failure(NetworkError.invalidResponse))
                return
            }
            
            logInfo("请求成功 - 状态码：\(httpResponse.statusCode)")
            logInfo("耗时：\(duration)秒")
            
            if duration > 3.0 {
                logWarning("请求耗时过长：\(duration)秒")
            }
            
            completion(.success(data ?? Data()))
        }.resume()
    }
}
```

### 示例2：用户操作追踪

```swift
class UserActionTracker {
    func trackLogin(userId: String) {
        logInfo("用户登录：user_id=\(userId)")
        logDebug("登录时间：\(Date())")
        logDebug("设备信息：\(UIDevice.current.model)")
    }
    
    func trackPurchase(productId: String, amount: Double) {
        logInfo("用户购买：product_id=\(productId), amount=\(amount)")
    }
    
    func trackCrash(error: Error) {
        logFatal("应用崩溃：\(error)")
        logFatal("堆栈信息：\(Thread.callStackSymbols)")
    }
}
```

### 示例3：性能监控

```swift
class PerformanceMonitor {
    func monitorMemory() {
        let usedMemory = getUsedMemory()
        let totalMemory = getTotalMemory()
        let percentage = (usedMemory / totalMemory) * 100
        
        if percentage > 80 {
            logWarning("内存使用率过高：\(Int(percentage))%")
        } else {
            logDebug("内存使用率：\(Int(percentage))%")
        }
    }
    
    func monitorFPS() {
        let fps = getCurrentFPS()
        
        if fps < 30 {
            logWarning("FPS 过低：\(fps)")
        } else if fps < 50 {
            logDebug("FPS：\(fps)")
        }
    }
}
```

---

## ⚠️ 注意事项

### 1. 避免敏感信息

```swift
// ❌ 不要记录敏感信息
logInfo("用户密码：\(password)")
logInfo("信用卡号：\(cardNumber)")

// ✅ 使用脱敏处理
logInfo("用户登录：user_id=\(userId)")
logInfo("支付成功：卡号尾号=\(cardNumber.suffix(4))")
```

### 2. 控制日志数量

```swift
// ❌ 避免在循环中大量输出
for i in 0..<10000 {
    logDebug("处理第 \(i) 条数据")  // 会输出 10000 条！
}

// ✅ 适度输出
for i in 0..<10000 {
    if i % 1000 == 0 {
        logDebug("处理进度：\(i)/10000")
    }
}
```

### 3. 线程安全

```swift
// Logger 是线程安全的，可以在任意线程调用
DispatchQueue.global().async {
    logInfo("后台线程执行")  // ✅ 安全
}
```

### 4. 文件清理

```swift
// 定期清理旧日志（可在应用启动时执行）
if let fileDestination = Logger.shared.destinations.first(where: { $0 is FileLogDestination }) as? FileLogDestination {
    fileDestination.clearAllLogs()
    logInfo("已清理旧日志文件")
}
```

---

## 🔍 调试技巧

### 1. 过滤日志

在 Xcode 控制台中使用搜索功能：
- 搜索 `[ERROR]` - 只看错误日志
- 搜索 `LoginViewController` - 只看特定文件的日志
- 搜索 `用户登录` - 搜索特定关键词

### 2. 临时调整级别

```swift
// 临时提高日志级别来排查问题
Logger.shared.minLevel = .verbose

// 排查完成后恢复
Logger.shared.minLevel = .info
```

### 3. 条件日志

```swift
#if DEBUG
logDebug("开发环境专用日志")
#endif

if isVerboseMode {
    logVerbose("详细追踪信息")
}
```

---

## 📊 性能影响

### 日志系统开销

| 操作 | 开销 | 说明 |
|------|------|------|
| 日志记录 | 极低 | 异步处理，不阻塞主线程 |
| 文件写入 | 低 | 后台队列，批量写入 |
| 字符串格式化 | 中 | 只在需要时执行 |
| 远程上报 | 中 | 缓冲机制，批量发送 |

### 优化建议

1. **开发环境**: 使用 VERBOSE/DEBUG，所有日志输出到控制台
2. **测试环境**: 使用 INFO，保存到文件
3. **生产环境**: 使用 WARNING，只记录警告和错误，上报严重错误

---

## 🎓 学习要点

### 1. 设计模式

- **策略模式**: LogFormatter 可替换的格式化策略
- **观察者模式**: 多个输出目标同时接收日志
- **单例模式**: Logger.shared 全局访问
- **工厂模式**: 创建不同类型的输出目标

### 2. Swift 特性

- **默认参数**: `#file`, `#function`, `#line`
- **协议**: LogFormatter, LogDestination
- **枚举**: LogLevel 级别定义
- **泛型**: 类型安全的日志系统

### 3. 线程安全

- **DispatchQueue**: 串行队列保护共享数据
- **NSRecursiveLock**: 递归锁避免死锁
- **弱引用**: 避免循环引用

---

## 📝 总结

日志框架演示展示了：

1. ✅ 完整的多级别日志系统
2. ✅ 灵活的输出目标配置
3. ✅ 强大的格式化功能
4. ✅ 文件轮转和管理
5. ✅ 远程日志上报
6. ✅ 线程安全设计
7. ✅ 企业级应用最佳实践

这是学习日志系统设计的优秀示例，展示了如何构建一个生产级别的日志框架。

---

## 🚀 下一步

- 体验不同级别的日志输出
- 查看控制台中的详细日志格式
- 尝试保存日志到文件
- 理解日志系统的架构设计
- 在自己的项目中集成日志框架

祝学习愉快！📝


