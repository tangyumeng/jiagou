# 路由传递复杂对象 - 快速测试指南

## ✅ 已完成的改动

### 新增文件

1. ✅ **RouteDataCache.swift** - 全局缓存管理器
   - 存储和获取复杂对象
   - 自动过期清理（TTL）
   - 线程安全实现

2. ✅ **RouteImagePreviewViewController** - 图片预览页面
   - 支持两种接收方式：parameters 和缓存 ID
   - 显示图片和尺寸信息

### 修改文件

1. ✅ **RoutePages.swift** - 添加图片预览页面类
2. ✅ **AppDelegate.swift** - 注册新路由
3. ✅ **RouterDemoViewController.swift** - 添加测试按钮

---

## 🚀 快速测试

### 测试 1：方式1 - Parameters 字典传递（推荐）

```
1. 运行 App（⌘ + R）
2. 主页 → 路由框架
3. 滚动到底部"📦 传递复杂对象"部分
4. 点击 [方式1：parameters 字典]
5. ✅ 进入图片预览页，显示动态生成的图片
```

**控制台日志：**
```
[10:30:00] 📤 测试传递 UIImage（方式1：parameters 字典）
[10:30:00] 📦 创建图片：300×200
[10:30:00] 📤 通过 parameters 直接传递 UIImage
[10:30:00] ✅ 路由匹配成功：app://image-preview
[10:30:00] 📝 参数：["image": <UIImage>, "title": "方式1：Parameters"]
[10:30:00] ✅ 跳转成功
```

**特点：**
- ✅ 直接传递 UIImage 对象
- ✅ 无需序列化
- ✅ 类型安全
- ✅ 最简单直接

---

### 测试 2：方式2 - 全局缓存 + ID

```
1. 运行 App
2. 主页 → 路由框架
3. 点击 [方式2：全局缓存 + ID]
4. ✅ 进入图片预览页，显示从缓存获取的图片
```

**控制台日志：**
```
[10:30:00] 📤 测试传递 UIImage（方式2：全局缓存）
[10:30:00] 📦 创建图片：300×200
[10:30:00] 📦 RouteDataCache: 存储对象 [ABC-123] TTL=60秒
[10:30:00] 📦 存储到缓存：ID = ABC-123
[10:30:00] 📤 通过 URL 传递 ID
[10:30:00] ✅ 路由匹配成功：app://image-preview/ABC-123
[10:30:00] 📦 从缓存获取图片：成功
[10:30:00] ✅ RouteDataCache: 获取并移除对象 [ABC-123]
[10:30:00] ✅ 跳转成功
```

**特点：**
- ✅ URL 简洁（只有 ID）
- ✅ 支持外部唤起
- ✅ 自动过期清理
- ✅ 适合大对象

---

## 💡 两种方式对比

### 界面对比

**方式1效果：**
- 图片上显示："Hello Router!"
- 页面标题："方式1：Parameters"
- 底部显示：图片尺寸 300 × 200

**方式2效果：**
- 图片上显示："Cache ID: 12345"
- 页面标题："图片预览"
- 底部显示：图片尺寸 300 × 200

### 技术对比

| 特性 | 方式1：Parameters | 方式2：缓存+ID |
|------|------------------|---------------|
| 简洁度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 外部唤起 | ❌ 不支持 | ✅ 支持 |
| 通知跳转 | ❌ 不支持 | ✅ 支持 |
| 类型安全 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 内存管理 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ (需清理) |
| URL 长度 | N/A | ⭐⭐⭐⭐⭐ |
| 性能 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

---

## 📊 代码详解

### 方式1：Parameters 字典

#### 传递代码

```swift
// 创建复杂对象
let image = createTestImage(text: "Hello Router!", size: CGSize(width: 300, height: 200))

// 直接通过 parameters 传递
Router.shared.open(
    "app://image-preview",
    parameters: [
        "image": image,        // ← UIImage 对象
        "title": "方式1：Parameters"
    ],
    from: self
)
```

#### 接收代码

```swift
class RouteImagePreviewViewController: UIViewController, Routable {
    var image: UIImage?
    var imageTitle: String?
    
    static func instantiate(with parameters: [String : Any]) -> Self? {
        let vc = Self()
        
        // 从 parameters 获取 UIImage
        vc.image = parameters["image"] as? UIImage
        vc.imageTitle = parameters["title"] as? String
        
        return vc
    }
}
```

**关键点：**
- `parameters` 是 `[String: Any]` 字典
- 可以传递任意类型的对象
- 直接传递对象引用，无需序列化

---

### 方式2：全局缓存 + ID

#### 传递代码

```swift
// 创建复杂对象
let image = createTestImage(text: "Cache ID: 12345", size: CGSize(width: 300, height: 200))

// 存储到全局缓存
let imageId = RouteDataCache.shared.storeImage(image, ttl: 60)
// 返回: "ABC-123-XYZ"

// URL 中只传递 ID
Router.shared.open("app://image-preview/\(imageId)", from: self)
// URL: "app://image-preview/ABC-123-XYZ"
```

#### 接收代码

```swift
class RouteImagePreviewViewController: UIViewController, Routable {
    var imageId: String?
    var image: UIImage?
    
    static func instantiate(with parameters: [String : Any]) -> Self? {
        let vc = Self()
        
        // 如果有 imageId，从缓存获取
        if let imageId = parameters["imageId"] as? String {
            vc.image = RouteDataCache.shared.fetchImage(imageId)
            print("📦 从缓存获取图片：\(vc.image != nil ? "成功" : "失败")")
        }
        
        return vc
    }
}
```

**关键点：**
- 使用 `RouteDataCache.shared.store()` 存储对象
- 获取唯一 ID
- URL 中传递 ID
- 目标页面通过 ID 获取对象
- `fetch()` 会自动移除缓存

---

## 🔍 RouteDataCache 详解

### 核心功能

```swift
class RouteDataCache {
    static let shared = RouteDataCache()
    
    // 存储对象（返回 ID）
    func store<T>(_ object: T, ttl: TimeInterval = 300) -> String
    
    // 获取对象（不移除）
    func get<T>(_ id: String) -> T?
    
    // 获取对象并移除（推荐）
    func fetch<T>(_ id: String) -> T?
    
    // 移除对象
    func remove(_ id: String)
    
    // 清空所有
    func removeAll()
}
```

### 生命周期管理

```swift
// 1. 存储时设置 TTL（生存时间）
let id = RouteDataCache.shared.store(image, ttl: 60)  // 60秒后过期

// 2. 使用后立即移除（推荐）
if let image: UIImage = RouteDataCache.shared.fetch(id) {
    // fetch() 会自动移除
    useImage(image)
}

// 3. 定时清理（每分钟自动执行）
// 自动清理过期对象
```

### 线程安全

```swift
// 使用并发队列 + barrier 标志
private let queue = DispatchQueue(label: "...", attributes: .concurrent)

// 读操作（并发）
func get<T>(_ id: String) -> T? {
    queue.sync { /* 读取 */ }
}

// 写操作（独占）
func store<T>(_ object: T) -> String {
    queue.async(flags: .barrier) { /* 写入 */ }
}
```

---

## 📱 实际应用场景

### 场景 1：图片选择器

```swift
// 打开图片选择器
Router.shared.open(
    "app://image-picker",
    parameters: [
        "onSelected": { (image: UIImage) in
            print("用户选择了图片")
            self.selectedImage = image
        }
    ]
)

// ImagePickerViewController
var onSelected: ((UIImage) -> Void)?

func imagePickerController(...) {
    if let image = ... {
        onSelected?(image)  // 回调
        dismiss(animated: true)
    }
}
```

### 场景 2：从通知预览图片

```swift
// 收到通知时
func didReceiveNotification(imageUrl: String) {
    // 1. 下载图片
    downloadImage(imageUrl) { image in
        // 2. 存储到缓存
        let imageId = RouteDataCache.shared.store(image)
        
        // 3. 发送本地通知
        let content = UNMutableNotificationContent()
        content.userInfo = [
            "route": "app://image-preview/\(imageId)"
        ]
        // ...
    }
}

// 用户点击通知
// → App 启动
// → Router 提取 imageId
// → 从缓存获取图片
// → 显示图片
```

### 场景 3：传递自定义对象

```swift
// 定义数据模型
struct ProductData {
    let id: Int
    let name: String
    let price: Double
}

// 传递数据 + 图片
let product = ProductData(id: 1, name: "iPhone", price: 5999)
let image = UIImage(named: "iphone")!

Router.shared.open(
    "app://product-detail",
    parameters: [
        "product": product,  // 自定义对象
        "image": image       // UIImage
    ]
)
```

### 场景 4：传递 NSData

```swift
// 传递文件数据
let fileData = try! Data(contentsOf: fileURL)

Router.shared.open(
    "app://file-preview",
    parameters: [
        "data": fileData,
        "filename": "document.pdf"
    ]
)
```

---

## ⚠️ 注意事项

### 1. 内存管理

```swift
// ✅ 推荐：使用 fetch()（会自动移除）
if let image = RouteDataCache.shared.fetch(id) {
    use(image)
}

// ❌ 避免：只用 get()（不会移除）
if let image = RouteDataCache.shared.get(id) {
    use(image)
    // 需要手动移除
    RouteDataCache.shared.remove(id)
}
```

### 2. TTL 设置

```swift
// 根据场景设置合适的 TTL

// 临时数据（1分钟）
RouteDataCache.shared.store(tempData, ttl: 60)

// 页面跳转（5分钟，默认）
RouteDataCache.shared.store(image, ttl: 300)

// 长期缓存（30分钟）
RouteDataCache.shared.store(largeData, ttl: 1800)
```

### 3. 类型安全

```swift
// ✅ 推荐：指定类型
let image: UIImage? = RouteDataCache.shared.fetch(id)

// ❌ 避免：使用 Any
let object: Any? = RouteDataCache.shared.fetch(id)
```

### 4. 循环引用

```swift
// ❌ 可能导致循环引用
Router.shared.open("...", parameters: [
    "callback": { self.doSomething() }  // 持有 self
])

// ✅ 使用 weak self
Router.shared.open("...", parameters: [
    "callback": { [weak self] in self?.doSomething() }
])
```

---

## 🎯 最佳实践

### 选择方案

```
需要传递复杂对象？
  ↓
应用内跳转？
  ↓ 是
  使用方式1：parameters 字典 ⭐⭐⭐⭐⭐
  - 简单直接
  - 类型安全
  - 无需管理生命周期
  
  ↓ 否（外部唤起、通知）
  使用方式2：全局缓存 + ID ⭐⭐⭐⭐
  - 支持外部唤起
  - URL 简洁
  - 提前准备数据
```

### 代码风格

```swift
// ✅ 好：清晰的参数名
Router.shared.open(
    "app://image-preview",
    parameters: [
        "image": myImage,
        "title": "我的照片"
    ]
)

// ❌ 差：含糊的参数名
Router.shared.open(
    "app://image-preview",
    parameters: [
        "data": myImage,
        "str": "我的照片"
    ]
)
```

---

## 📚 相关文档

- **路由传递复杂对象方案.md** - 完整技术方案
- **Router演示说明.md** - 基础路由使用
- **通知路由启动方案.md** - 从通知启动

---

## ✅ 验证清单

测试完成后，请确认：

- [ ] 方式1（parameters）能正常传递图片 ✅
- [ ] 方式2（缓存）能正常传递图片 ✅
- [ ] 图片在预览页正确显示 ✅
- [ ] 控制台日志正确输出 ✅
- [ ] 缓存自动清理工作正常 ✅

---

## 🎉 总结

### 实现的功能

✅ **方式1：Parameters** - 直接传递对象  
✅ **方式2：缓存+ID** - 支持外部唤起  
✅ **RouteDataCache** - 全局缓存管理  
✅ **自动清理** - TTL 过期机制  
✅ **线程安全** - 并发队列保护  
✅ **测试工具** - 完整示例代码  

### 技术价值

🎯 **解决实际问题** - UIImage、NSData 传递  
🎯 **两种方案** - 应用内 + 外部唤起  
🎯 **生产级代码** - 线程安全、内存管理  
🎯 **面试价值** - 缓存设计、路由解耦  

---

**立即运行项目测试两种传递方式！📱**

**主页 → 路由框架 → 滚动到底部 → 点击测试按钮！🚀**

