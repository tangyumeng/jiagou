# 路由传递复杂对象方案

## 📌 问题背景

**问题：** "Route 怎样传复杂对象，比如 UIImage、NSData 等类型数据"

### 核心限制

```
URL-Based 路由的限制：
❌ URL 只能包含字符串
❌ Query 参数只能是 String 类型
❌ 无法直接传递对象引用

需要解决：
✅ 如何传递 UIImage？
✅ 如何传递 NSData？
✅ 如何传递自定义对象？
✅ 如何传递闭包？
```

---

## 🎯 解决方案对比

### 方案对比表

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **1. parameters 字典** | ✅ 简单直接<br>✅ 类型安全<br>✅ 无需序列化 | ❌ 仅限内部路由<br>❌ 不支持外部唤起 | 应用内跳转 |
| **2. 全局缓存** | ✅ 支持外部唤起<br>✅ URL 简洁 | ❌ 需要管理生命周期<br>❌ 内存占用 | 大对象传递 |
| **3. 单例/Manager** | ✅ 统一管理<br>✅ 可持久化 | ❌ 全局状态<br>❌ 耦合性 | 共享数据 |
| **4. 序列化** | ✅ 支持外部唤起<br>✅ 可持久化 | ❌ URL 过长<br>❌ 性能开销 | 小对象，外部唤起 |

---

## 💻 方案 1：通过 parameters 字典传递（推荐⭐）

### 原理

我们的 Router 已经支持 `parameters` 参数，可以传递任意类型的对象！

```swift
func open(
    _ urlString: String,
    parameters: [String: Any] = [:],  // ← 这里可以传递任意对象
    from source: UIViewController? = nil,
    animated: Bool = true,
    completion: (() -> Void)? = nil
) -> Bool
```

### 实现示例

#### 1. 注册路由

```swift
// 在 AppDelegate 中注册
router.register("app://image-preview", viewControllerType: ImagePreviewViewController.self)
```

#### 2. 创建接收复杂对象的 ViewController

```swift
class ImagePreviewViewController: UIViewController, Routable {
    
    // 接收复杂对象
    var image: UIImage?
    var imageData: NSData?
    var customObject: CustomModel?
    var completion: (() -> Void)?
    
    static func instantiate(with parameters: [String : Any]) -> Self? {
        let vc = Self()
        
        // 从 parameters 中提取复杂对象
        vc.image = parameters["image"] as? UIImage
        vc.imageData = parameters["imageData"] as? NSData
        vc.customObject = parameters["customObject"] as? CustomModel
        vc.completion = parameters["completion"] as? (() -> Void)
        
        return vc
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        title = "图片预览"
        view.backgroundColor = .systemBackground
        
        // 使用传递的对象
        if let image = image {
            let imageView = UIImageView(image: image)
            imageView.contentMode = .scaleAspectFit
            // ... 设置约束
        }
    }
}
```

#### 3. 传递复杂对象

```swift
// 创建复杂对象
let image = UIImage(named: "test")!
let imageData = image.pngData()! as NSData
let customObject = CustomModel(name: "测试", value: 100)

// 通过 parameters 传递
Router.shared.open(
    "app://image-preview",
    parameters: [
        "image": image,              // UIImage
        "imageData": imageData,      // NSData
        "customObject": customObject, // 自定义对象
        "completion": {              // 闭包
            print("页面已关闭")
        }
    ]
)
```

### 优点

✅ **类型安全** - 编译时检查类型  
✅ **无需序列化** - 直接传递对象引用  
✅ **支持任意类型** - UIImage、NSData、闭包等  
✅ **性能好** - 无额外开销  
✅ **代码简洁** - 一行代码完成  

### 缺点

❌ **仅限内部** - 只能应用内跳转  
❌ **不支持外部唤起** - 无法通过 URL Scheme 传递  
❌ **不支持通知** - 推送通知无法传递对象  

### 适用场景

✅ 应用内页面跳转  
✅ 预览图片、视频  
✅ 传递选中的数据模型  
✅ 传递回调闭包  

---

## 💻 方案 2：全局缓存 + ID 传递

### 原理

```
1. 将复杂对象存储到全局缓存
2. 生成唯一 ID
3. URL 中只传递 ID
4. 目标页面通过 ID 获取对象
5. 使用后从缓存中移除
```

### 实现代码

#### 1. 创建全局缓存管理器

```swift
// RouteDataCache.swift

class RouteDataCache {
    
    // MARK: - 单例
    static let shared = RouteDataCache()
    
    // MARK: - 缓存存储
    private var cache: [String: Any] = [:]
    private let queue = DispatchQueue(label: "com.router.datacache", attributes: .concurrent)
    
    private init() {}
    
    // MARK: - 存储对象
    
    /// 存储对象并返回 ID
    func store<T>(_ object: T) -> String {
        let id = UUID().uuidString
        queue.async(flags: .barrier) { [weak self] in
            self?.cache[id] = object
        }
        return id
    }
    
    // MARK: - 获取对象
    
    /// 获取对象（不移除）
    func get<T>(_ id: String) -> T? {
        var result: T?
        queue.sync {
            result = cache[id] as? T
        }
        return result
    }
    
    /// 获取对象并移除
    func fetch<T>(_ id: String) -> T? {
        var result: T?
        queue.sync(flags: .barrier) { [weak self] in
            result = self?.cache[id] as? T
            self?.cache.removeValue(forKey: id)
        }
        return result
    }
    
    // MARK: - 移除对象
    
    /// 移除指定对象
    func remove(_ id: String) {
        queue.async(flags: .barrier) { [weak self] in
            self?.cache.removeValue(forKey: id)
        }
    }
    
    /// 清空所有缓存
    func removeAll() {
        queue.async(flags: .barrier) { [weak self] in
            self?.cache.removeAll()
        }
    }
    
    // MARK: - 调试
    
    var cacheCount: Int {
        var count = 0
        queue.sync {
            count = cache.count
        }
        return count
    }
}
```

#### 2. 使用缓存传递对象

```swift
// 存储复杂对象
let image = UIImage(named: "test")!
let imageId = RouteDataCache.shared.store(image)

// URL 中只传递 ID
Router.shared.open("app://image-preview/\(imageId)")
```

#### 3. 目标页面获取对象

```swift
class ImagePreviewViewController: UIViewController, Routable {
    
    var imageId: String?
    var image: UIImage?
    
    static func instantiate(with parameters: [String : Any]) -> Self? {
        let vc = Self()
        vc.imageId = parameters["imageId"] as? String
        return vc
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 从缓存中获取对象（并移除）
        if let imageId = imageId,
           let image: UIImage = RouteDataCache.shared.fetch(imageId) {
            self.image = image
            print("✅ 成功获取图片：\(image.size)")
        }
    }
}
```

### 生命周期管理

#### 自动清理策略

```swift
class RouteDataCache {
    
    // 添加时间戳
    private struct CacheItem {
        let object: Any
        let timestamp: Date
    }
    
    private var cache: [String: CacheItem] = [:]
    
    // 存储时记录时间
    func store<T>(_ object: T, ttl: TimeInterval = 300) -> String {
        let id = UUID().uuidString
        let item = CacheItem(object: object, timestamp: Date())
        queue.async(flags: .barrier) { [weak self] in
            self?.cache[id] = item
        }
        
        // 自动清理（5分钟后）
        DispatchQueue.global().asyncAfter(deadline: .now() + ttl) { [weak self] in
            self?.remove(id)
        }
        
        return id
    }
}
```

### 优点

✅ **支持外部唤起** - URL 中只有 ID  
✅ **URL 简洁** - 不会过长  
✅ **支持大对象** - 图片、视频等  
✅ **支持通知** - 可在通知中传递 ID  

### 缺点

❌ **需要管理生命周期** - 防止内存泄漏  
❌ **线程安全** - 需要加锁  
❌ **内存占用** - 大对象占用内存  

### 适用场景

✅ 从通知跳转（提前缓存数据）  
✅ 外部 URL 唤起（提前准备数据）  
✅ 传递大对象（图片、视频）  
✅ 跨模块数据传递  

---

## 💻 方案 3：单例/Manager 管理

### 原理

```
使用单例或 Manager 类存储共享数据
页面通过单例获取数据
适合全局共享的数据
```

### 实现示例

#### 1. 创建数据管理器

```swift
class SharedDataManager {
    static let shared = SharedDataManager()
    
    // 共享数据
    var currentImage: UIImage?
    var currentUser: User?
    var selectedItems: [Item] = []
    
    private init() {}
    
    // 便捷方法
    func setImage(_ image: UIImage) {
        currentImage = image
    }
    
    func getImage() -> UIImage? {
        let image = currentImage
        currentImage = nil  // 获取后清除
        return image
    }
}
```

#### 2. 设置数据并跳转

```swift
// 设置共享数据
let image = UIImage(named: "test")!
SharedDataManager.shared.setImage(image)

// 跳转
Router.shared.open("app://image-preview")
```

#### 3. 目标页面获取数据

```swift
class ImagePreviewViewController: UIViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 从单例获取数据
        if let image = SharedDataManager.shared.getImage() {
            print("✅ 获取到图片")
            // 使用图片
        }
    }
}
```

### 优点

✅ **全局访问** - 任何地方都能获取  
✅ **统一管理** - 集中管理数据  
✅ **简单直接** - 代码简洁  

### 缺点

❌ **全局状态** - 难以追踪数据流  
❌ **耦合性高** - 依赖单例  
❌ **测试困难** - 全局状态影响测试  

### 适用场景

✅ 用户信息、配置等全局数据  
✅ 临时共享数据  
✅ 购物车、选中项等  

---

## 💻 方案 4：序列化传递（不推荐）

### 原理

```
1. 将对象序列化为字符串（JSON、Base64）
2. 放入 URL Query 参数
3. 目标页面反序列化
```

### 实现示例

```swift
// 序列化对象
let model = CustomModel(name: "测试", value: 100)
let jsonData = try! JSONEncoder().encode(model)
let base64String = jsonData.base64EncodedString()

// 传递
Router.shared.open("app://detail?data=\(base64String)")

// 反序列化
if let dataString = parameters["data"] as? String,
   let data = Data(base64Encoded: dataString),
   let model = try? JSONDecoder().decode(CustomModel.self, from: data) {
    self.model = model
}
```

### 优点

✅ **支持外部唤起**  
✅ **可持久化**  

### 缺点

❌ **URL 过长** - 可能超过限制  
❌ **性能开销** - 序列化/反序列化  
❌ **类型限制** - 只能传递 Codable 对象  
❌ **无法传递 UIImage** - 图片太大  

### 适用场景

✅ 小对象（< 1KB）  
✅ 外部唤起时传递参数  
✅ Universal Links  

---

## 🎯 推荐方案选择

### 决策树

```
需要传递复杂对象？
  ↓
应用内跳转？
  ↓ 是
  使用方案1：parameters 字典 ⭐⭐⭐⭐⭐
  
  ↓ 否（外部唤起）
  
对象大小？
  ↓ 小（< 1KB）
  使用方案4：序列化 ⭐⭐⭐
  
  ↓ 大（图片、视频）
  使用方案2：全局缓存 ⭐⭐⭐⭐
```

### 场景推荐

| 场景 | 推荐方案 | 理由 |
|------|---------|------|
| 预览图片 | 方案1（parameters） | 简单直接 |
| 编辑数据 | 方案1（parameters） | 类型安全 |
| 传递回调 | 方案1（parameters） | 唯一选择 |
| 通知跳转 | 方案2（缓存） | 提前准备数据 |
| URL Scheme | 方案2（缓存） | 支持复杂对象 |
| 全局数据 | 方案3（单例） | 统一管理 |
| 小对象外部唤起 | 方案4（序列化） | 支持外部 |

---

## 📊 完整示例

### 示例 1：传递图片（应用内）

```swift
// 方案1：parameters 字典
let image = UIImage(named: "test")!

Router.shared.open(
    "app://image-preview",
    parameters: [
        "image": image,
        "title": "美丽的风景"
    ]
)
```

### 示例 2：传递图片（从通知）

```swift
// 收到通知时，预先缓存图片
func didReceiveNotification(imageUrl: String) {
    // 下载图片
    downloadImage(imageUrl) { image in
        // 存储到缓存
        let imageId = RouteDataCache.shared.store(image)
        
        // 发送本地通知
        let content = UNMutableNotificationContent()
        content.userInfo = [
            "route": "app://image-preview/\(imageId)"
        ]
        // ...
    }
}

// 点击通知后
// 路由自动提取 imageId
// ImagePreviewViewController 从缓存获取图片
```

### 示例 3：传递自定义对象

```swift
struct Product: Codable {
    let id: Int
    let name: String
    let price: Double
    let image: UIImage  // ❌ 不能放在 Codable 中
}

// 正确做法：分离数据和图片
let product = ProductData(id: 1, name: "iPhone", price: 5999)
let image = UIImage(named: "iphone")!

Router.shared.open(
    "app://product-detail",
    parameters: [
        "product": product,
        "image": image
    ]
)
```

### 示例 4：传递闭包回调

```swift
// 选择图片后回调
Router.shared.open(
    "app://image-picker",
    parameters: [
        "onImageSelected": { (image: UIImage) in
            print("用户选择了图片：\(image.size)")
            self.selectedImage = image
        }
    ]
)

// ImagePickerViewController
var onImageSelected: ((UIImage) -> Void)?

func imagePickerController(..., didFinishPickingMediaWithInfo info: ...) {
    if let image = info[.originalImage] as? UIImage {
        onImageSelected?(image)  // 回调
        dismiss(animated: true)
    }
}
```

---

## 🔍 最佳实践

### 1. 优先使用 parameters

```swift
✅ 推荐：
Router.shared.open("app://detail", parameters: ["data": complexObject])

❌ 避免：
let jsonString = serialize(complexObject)
Router.shared.open("app://detail?data=\(jsonString)")
```

### 2. 大对象使用缓存

```swift
✅ 推荐（图片、视频）：
let id = RouteDataCache.shared.store(largeObject)
Router.shared.open("app://preview/\(id)")

❌ 避免：
Router.shared.open("app://preview", parameters: ["large": largeObject])
// 如果对象过大，会占用内存
```

### 3. 及时清理缓存

```swift
// 使用后立即清理
if let data = RouteDataCache.shared.fetch(id) {
    // fetch 会自动移除
    use(data)
}

// 或在 deinit 中清理
deinit {
    if let id = dataId {
        RouteDataCache.shared.remove(id)
    }
}
```

### 4. 类型安全

```swift
✅ 推荐：使用具体类型
var image: UIImage?
image = parameters["image"] as? UIImage

❌ 避免：使用 Any
var data: Any?
data = parameters["data"]  // 不知道是什么类型
```

---

## ⚠️ 注意事项

### 1. 内存管理

```swift
// ❌ 可能导致循环引用
Router.shared.open("app://detail", parameters: [
    "completion": { self.doSomething() }  // 持有 self
])

// ✅ 使用 weak self
Router.shared.open("app://detail", parameters: [
    "completion": { [weak self] in self?.doSomething() }
])
```

### 2. 线程安全

```swift
// 缓存需要线程安全
private let queue = DispatchQueue(label: "...", attributes: .concurrent)

func store() {
    queue.async(flags: .barrier) {
        // 写操作
    }
}

func get() {
    queue.sync {
        // 读操作
    }
}
```

### 3. 生命周期

```swift
// 缓存对象需要设置过期时间
func store<T>(_ object: T, ttl: TimeInterval = 300) -> String {
    // 5分钟后自动清理
}
```

---

## 📚 相关文档

- **Router 演示说明.md** - 基础路由使用
- **通知路由启动方案.md** - 从通知启动
- **路由框架说明.md** - 完整文档

---

## ✅ 总结

### 方案对比

| 方案 | 应用内 | 外部唤起 | 性能 | 复杂度 | 推荐度 |
|------|--------|---------|------|--------|--------|
| parameters | ✅ | ❌ | ⭐⭐⭐⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ |
| 全局缓存 | ✅ | ✅ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| 单例管理 | ✅ | ✅ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| 序列化 | ✅ | ✅ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ |

### 核心建议

✅ **首选 parameters** - 90% 的场景都适用  
✅ **大对象用缓存** - 图片、视频、大数据  
✅ **外部唤起用缓存+ID** - 提前准备数据  
✅ **避免序列化** - 除非必须外部唤起小对象  

---

**立即查看实战示例代码！📱**

